---
title: A comparison of language control while switching within versus between languages in younger and older adults.
author: "Angela de Bruin*$^1$, Heidi Kressel$^2$, & Daisy Hemmings$^2$"
output:
   #html_document: default
   bookdown::pdf_document2:
    keep_tex: true
    toc: false
    fig_caption: yes
   pdf_document: default
    
header-includes:
  \newcommand{\beginsupplement}{\setcounter{table}{0}       
  \renewcommand{\thetable}{S\arabic{table}} \setcounter{figure}{0} 
  \renewcommand{\thefigure}{S\arabic{figure}}}
editor_options: 
  chunk_output_type: inline
---

``` {r setup, include=FALSE}

# flag to specify if analyses are done from scratch (takes ~6 minutes)
# if set to 0, precomputed analyses are loaded from an RData file
doanalysis <- 1

#Note: data were analysed using lme4 package version 1.1.33 and lmerTest 3.1.3 in R 4.3.0

packagelist <- c('lme4','lmerTest','tidyverse','ggplot2','rmarkdown','bookdown','rstatix','devtools')
missingpackages <- packagelist[!packagelist %in% installed.packages()[,1]]
if (length(missingpackages)>0){install.packages(missingpackages)}
toinstall <- packagelist[which(!packagelist %in% (.packages()))]
invisible(lapply(toinstall,library,character.only=TRUE))

devtools::install_github("kupietz/kableExtra")
library(kableExtra)

knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

```

``` {r trimmingfunction, include=FALSE}

#------------------------------------------------------------------------------
#' RT trimming with standard deviation criterion (Grange, 2017, sdtrim package)
#'
#' \code{sdTrim} takes a data frame of RT data and returns trimmed rt
#' data that fall below a set set criterion (based on standard deviations
#' above a particular mean). The criterion can be based on the mean of the
#' whole set of data, based on the mean per experimental condition, based on
#' the mean per participant, or based on the mean of each participant in each
#' experimental condition.
#'
#' By passing a data frame containing raw response time data, together with
#' trimming criteria, the function will return trimmed data, either in the form
#' of trial-level data or in the form of means/medians for each subject &
#' condition.
#'
#' @param data A data frame. It must contain columns named "participant",
#' "condition", "rt", and "accuracy". The RT can be in seconds
#' (e.g., 0.654) or milliseconds (e.g., 654). Condition will consist
#' of strings. "accuracy" must be 1 for correct and 0 for error
#' responses.
#' @param minRT The lower criteria for acceptable response time. Must be in
#' the same form as rt column in data frame (e.g., in seconds OR milliseconds).
#' All RTs below this value are removed before proceeding with SD trimming.
#' @param sd The upper criteria for standard deviation cut-off.
#' @param perCondition Set to TRUE if the user wishes the trimming to occur per
#' condition of the experimental design.
#' @param perParticipant Set to TRUE if the user wishes the trimming to occur
#' per participant.
#' @param omitErrors If set to TRUE, error trials will be removed before
#' conducting trimming procedure. Final data returned will not be influenced
#' by errors in this case.
#' @param returnType Request nature of returned data. "raw" returns trial-
#' level data excluding trimmed data; "mean" returns mean response times per
#' participant for each experimental condition identified; "median" returns
#' median response times per participant for each experimental condition
#' identified.
#' @param digits How many decimal places to round to after trimming?
#' @examples
#' # load the example data that ships with trimr
#' data(exampleData)
#'
#' # perform the trimming with SD trimming per condition, returning mean RT
#' trimmedData <- sdTrim(data = exampleData, minRT = 150, sd = 2.5,
#' perCondition = TRUE, perParticipant = FALSE, returnType = "mean")
#'
#' @importFrom stats median sd
#'
#' @export
sdTrim <- function(data, minRT, sd, perCondition = TRUE, perParticipant = TRUE,
                   omitErrors = TRUE, returnType = "mean", digits = 3){
  
  ###-------------
  if(perCondition == FALSE & perParticipant == FALSE){
    # change the variable name for sd (as this is an R function)
    stDev <- sd
    
    # remove errors if the user has asked for it
    if(omitErrors == TRUE){
      trimmedData <- subset(data, data$accuracy == 1)
    } else {
      trimmedData <- data
    }
    
    # get the list of participant numbers
    participant <- sort(unique(trimmedData$participant))
    
    # get the list of experimental conditions
    conditionList <- unique(trimmedData$condition)
    
    # trim the data to remove trials below minRT
    trimmedData <- subset(trimmedData, trimmedData$rt > minRT)
    
    # what is the mean & SD of the whole group's data?
    meanRT <- mean(trimmedData$rt)
    sdRT <- sd(trimmedData$rt)
    
    # what is the cut-off value?
    cutoff <- meanRT + (stDev * sdRT)
    
    # remove these rts
    trimmedData <- subset(trimmedData, trimmedData$rt < cutoff)
    
    
    # if the user asked for trial-level data, return immediately to user
    if(returnType == "raw"){
      return(trimmedData)
    }
    
    # if the user has asked for means, then split the data into separate
    # conditions, and display the means per condition.
    if(returnType == "mean"){
      
      # ready the final data set
      finalData <- matrix(0, nrow = length(participant),
                          ncol = length(conditionList))
      
      # give the columns the condition names
      colnames(finalData) <- conditionList
      
      # add the participant column
      finalData <- cbind(participant, finalData)
      
      # convert to data frame
      finalData <- data.frame(finalData)
      
      
      # loop over all conditions, and over all subjects, and find mean RT
      
      j <- 2 # to keep track of conditions looped over. Starts at 2 as this is
      # where the first condition's column is.
      
      for(currCondition in conditionList){
        
        # get the current condition's data
        tempData <- subset(trimmedData, trimmedData$condition == currCondition)
        
        
        
        #now loop over all participants
        i <- 1
        
        for(currParticipant in participant){
          
          # get that participant's data
          participantData <- subset(tempData,
                                    tempData$participant == currParticipant)
          
          # calculate & store their mean response time
          finalData[i, j] <- round(mean(participantData$rt), digits = digits)
          
          # update participant counter
          i <- i + 1
        }
        
        # update nCondition counter
        j <- j + 1
        
      } # end of condition loop
      
      return(finalData)
      
    } ## end MEAN sub-function
    
    
    # if the user has asked for medians, then split the data into separate
    # conditions, and display the medians per condition.
    if(returnType == "median"){
      
      # ready the final data set
      finalData <- matrix(0, nrow = length(participant),
                          ncol = length(conditionList))
      
      # give the columns the condition names
      colnames(finalData) <- conditionList
      
      # add the participant column
      finalData <- cbind(participant, finalData)
      
      # convert to data frame
      finalData <- data.frame(finalData)
      
      
      # loop over all conditions, and over all subjects, and find mean RT
      
      j <- 2 # to keep track of conditions looped over. Starts at 2 as this is
      # where the first condition's column is.
      
      for(currCondition in conditionList){
        
        # get the current condition's data
        tempData <- subset(trimmedData, trimmedData$condition == currCondition)
        
        
        #now loop over all participants
        i <- 1
        
        for(currParticipant in participant){
          
          # get that participant's data
          participantData <- subset(tempData,
                                    tempData$participant == currParticipant)
          
          # calculate & store their mean response time
          finalData[i, j] <- round(median(participantData$rt), digits = digits)
          
          # update participant counter
          i <- i + 1
        }
        
        
        # update nCondition counter
        j <- j + 1
        
      } # end of condition loop
      
      return(finalData)
    }
    
  } # end of perCell == FALSE & perParticipant == FALSE
  
  
  ###-------------
  if(perCondition == TRUE & perParticipant == FALSE){
    
    # change the variable name for sd (as this is an R function)
    stDev <- sd
    
    # remove errors if the user has asked for it
    if(omitErrors == TRUE){
      trimmedData <- subset(data, data$accuracy == 1)
    } else {
      trimmedData <- data
    }
    
    # get the list of participant numbers
    participant <- sort(unique(trimmedData$participant))
    
    # get the list of experimental conditions
    conditionList <- unique(trimmedData$condition)
    
    # trim the data to remove trials below minRT
    trimmedData <- subset(trimmedData, trimmedData$rt > minRT)
    
    ### do "raw"
    if(returnType == "raw"){
      
      # initialise variable to keep trimmed data in
      finalData <- NULL
      
      # loop over each condition
      for(cond in conditionList){
        
        # get the data, & find cutoff
        curData <- subset(trimmedData, trimmedData$condition == cond)
        curMean <- mean(curData$rt)
        curSD <- sd(curData$rt)
        curCutoff <- curMean + (stDev * curSD)
        curCutoff2 <- curMean - (stDev * curSD)
        
        # trim the data
        curData <- subset(curData, curData$rt < curCutoff & curData$rt > curCutoff2)
        
        # bind the data
        finalData <- rbind(finalData, curData)
      }
      
      return(finalData)
    }
    
    ### do "mean"
    if(returnType == "mean"){
      
      ## first, find the cutoff for each condition, and remove the necessary
      ## trials
      
      # initialise variable to keep trimmed data in
      tempData <- NULL
      
      for(cond in conditionList){
        # get the data, & find cutoff
        curData <- subset(trimmedData, trimmedData$condition == cond)
        curMean <- mean(curData$rt)
        curSD <- sd(curData$rt)
        curCutoff <- curMean + (stDev * curSD)
        
        # trim the data
        curData <- subset(curData, curData$rt < curCutoff)
        
        # bind the data
        tempData <- rbind(tempData, curData)
      }
      
      # change variable names
      trimmedData <- tempData
      tempData <- NULL
      
      ## now loop over each subject and calculate their average
      # ready the final data set
      finalData <- matrix(0, nrow = length(participant),
                          ncol = length(conditionList))
      
      # give the columns the condition names
      colnames(finalData) <- conditionList
      
      # add the participant column
      finalData <- cbind(participant, finalData)
      
      # convert to data frame
      finalData <- data.frame(finalData)
      
      # loop over conditions & subjects and calculate their average
      
      # to index over conditions. It starts at 2 because this is the first
      # column in the data frame containing condition information
      j <- 2
      
      for(curCondition in conditionList){
        
        # get the current condition's data
        tempData <- subset(trimmedData, trimmedData$condition == curCondition)
        
        #now loop over all participants
        i <- 1
        
        for(currParticipant in participant){
          
          # get that participant's data
          participantData <- subset(tempData,
                                    tempData$participant == currParticipant)
          
          # calculate & store their mean response time
          finalData[i, j] <- round(mean(participantData$rt), digits = digits)
          
          # update participant counter
          i <- i + 1
        }
        
        # update nCondition counter
        j <- j + 1
      }
      
      return(finalData)
    }
    
  } # end of perCell == TRUE & perParticipant == FALSE
  
  
  ###-------------
  if(perCondition == FALSE & perParticipant == TRUE){
    
    # change the variable name for sd (as this is an R function)
    stDev <- sd
    
    # remove errors if the user has asked for it
    if(omitErrors == TRUE){
      trimmedData <- subset(data, data$accuracy == 1)
    } else {
      trimmedData <- data
    }
    
    # get the list of participant numbers
    participant <- sort(unique(trimmedData$participant))
    
    # get the list of experimental conditions
    conditionList <- unique(trimmedData$condition)
    
    # trim the data to remove trials below minRT
    trimmedData <- subset(trimmedData, trimmedData$rt > minRT)
    
    
    ### do "raw"
    if(returnType == "raw"){
      
      # initialise variable to keep trimmed data in
      finalData <- NULL
      
      # loop over each subject
      for(currSub in participant){
        
        # get the current subject's data
        curData <- subset(trimmedData, trimmedData$participant == currSub)
        
        # find their mean, sd, & cutoff
        curMean <- mean(curData$rt)
        curSD <- sd(curData$rt)
        curCutoff <- curMean + (stDev * curSD)
        
        # trim the data
        curData <- subset(curData, curData$rt < curCutoff)
        
        # bind the data
        finalData <- rbind(finalData, curData)
      }
      
      return(finalData)
    }
    
    
    ### do "mean"
    if(returnType == "mean"){
      
      # initialise variable to keep trimmed data in
      tempData <- NULL
      
      # loop over each subject
      for(currSub in participant){
        
        # get the current subject's data
        curData <- subset(trimmedData, trimmedData$participant == currSub)
        
        # find their mean, sd, & cutoff
        curMean <- mean(curData$rt)
        curSD <- sd(curData$rt)
        curCutoff <- curMean + (stDev * curSD)
        
        # trim the data
        curData <- subset(curData, curData$rt < curCutoff)
        
        # bind the data
        tempData <- rbind(tempData, curData)
      }
      
      # change variable names
      trimmedData <- tempData
      tempData <- NULL
      
      # ready the final data set
      finalData <- matrix(0, nrow = length(participant),
                          ncol = length(conditionList))
      
      # give the columns the condition names
      colnames(finalData) <- conditionList
      
      # add the participant column
      finalData <- cbind(participant, finalData)
      
      # convert to data frame
      finalData <- data.frame(finalData)
      
      # loop over conditions & subjects and calculate their average
      
      # to index over conditions. It starts at 2 because this is the first
      # column in the data frame containing condition information
      j <- 2
      
      for(curCondition in conditionList){
        
        # get the current condition's data
        tempData <- subset(trimmedData, trimmedData$condition == curCondition)
        
        #now loop over all participants
        i <- 1
        
        for(currParticipant in participant){
          
          # get that participant's data
          participantData <- subset(tempData,
                                    tempData$participant == currParticipant)
          
          # calculate & store their mean response time
          finalData[i, j] <- round(mean(participantData$rt), digits = digits)
          
          # update participant counter
          i <- i + 1
        }
        
        # update nCondition counter
        j <- j + 1
      }
      
      return(finalData)
      
    }
    
    
    ### do "median"
    if(returnType == "median"){
      
      # initialise variable to keep trimmed data in
      tempData <- NULL
      
      # loop over each subject
      for(currSub in participant){
        
        # get the current subject's data
        curData <- subset(trimmedData, trimmedData$participant == currSub)
        
        # find their mean, sd, & cutoff
        curMean <- mean(curData$rt)
        curSD <- sd(curData$rt)
        curCutoff <- curMean + (stDev * curSD)
        
        # trim the data
        curData <- subset(curData, curData$rt < curCutoff)
        
        # bind the data
        tempData <- rbind(tempData, curData)
      }
      
      # change variable names
      trimmedData <- tempData
      tempData <- NULL
      
      # ready the final data set
      finalData <- matrix(0, nrow = length(participant),
                          ncol = length(conditionList))
      
      # give the columns the condition names
      colnames(finalData) <- conditionList
      
      # add the participant column
      finalData <- cbind(participant, finalData)
      
      # convert to data frame
      finalData <- data.frame(finalData)
      
      # loop over conditions & subjects and calculate their average
      
      # to index over conditions. It starts at 2 because this is the first
      # column in the data frame containing condition information
      j <- 2
      
      for(curCondition in conditionList){
        
        # get the current condition's data
        tempData <- subset(trimmedData, trimmedData$condition == curCondition)
        
        #now loop over all participants
        i <- 1
        
        for(currParticipant in participant){
          
          # get that participant's data
          participantData <- subset(tempData,
                                    tempData$participant == currParticipant)
          
          # calculate & store their median response time
          finalData[i, j] <- round(median(participantData$rt), digits = digits)
          
          # update participant counter
          i <- i + 1
        }
        
        # update nCondition counter
        j <- j + 1
      }
      
      return(finalData)
    }
    
    
  } # end of perCell == FALSE & perParticipant == TRUE
  
  
  
  ###-------------
  if(perCondition == TRUE & perParticipant == TRUE){
    # change the variable name for sd (as this is an R function)
    stDev <- sd
    
    # remove errors if the user has asked for it
    if(omitErrors == TRUE){
      trimmedData <- subset(data, data$accuracy == 1)
    } else {
      trimmedData <- data
    }
    
    # get the list of participant numbers
    participant <- sort(unique(trimmedData$participant))
    
    # get the list of experimental conditions
    conditionList <- unique(trimmedData$condition)
    
    # trim the data to remove trials below minRT
    trimmedData <- subset(trimmedData, trimmedData$rt > minRT)
    
    ### do "raw"
    if(returnType == "raw"){
      
      # initialise variable to keep trimmed data in
      finalData <- NULL
      
      # loop over all participants
      for(currSub in participant){
        
        # loop over all conditions
        for(currCond in conditionList){
          
          # get the relevant data
          tempData <- subset(trimmedData, trimmedData$condition == currCond &
                               trimmedData$participant == currSub)
          
          # find the cutoff
          curMean <- mean(tempData$rt)
          curSD <- sd(tempData$rt)
          curCutoff <- curMean + (stDev * curSD)
          
          # perform the trim
          curData <- subset(tempData, tempData$rt < curCutoff)
          
          # store the data
          finalData <- rbind(finalData, curData)
        }
      }
      
      return(finalData)
    }
    
    
    
    ### do "mean"
    if(returnType == "mean"){
      
      # ready the final data set
      finalData <- matrix(0, nrow = length(participant),
                          ncol = length(conditionList))
      
      # give the columns the condition names
      colnames(finalData) <- conditionList
      
      # add the participant column
      finalData <- cbind(participant, finalData)
      
      # convert to data frame
      finalData <- data.frame(finalData)
      
      # intialise looping variable for subjects
      i <- 1
      
      # loop over all subjects
      for(currSub in participant){
        
        # intialise looping variable for conditions. It starts at 2 because the
        # first column in the data file containing condition information is the
        # second one.
        j <- 2
        
        # loop over all conditions
        for(currCond in conditionList){
          
          # get the relevant data
          tempData <- subset(trimmedData, trimmedData$participant == currSub &
                               trimmedData$condition == currCond)
          
          # find the cutoff
          curMean <- mean(tempData$rt)
          curSD <- sd(tempData$rt)
          curCutoff <- curMean + (stDev * curSD)
          
          # trim the data
          curData <- subset(tempData, tempData$rt < curCutoff)
          
          # find the average, and add to the data frame
          finalData[i, j] <- round(mean(curData$rt), digits = digits)
          
          # update condition loop counter
          j <- j + 1
        }
        
        # update participant loop counter
        i <- i + 1
      }
      
      return(finalData)
      
    }
    
    
    ### do "median"
    if(returnType == "median"){
      
      # ready the final data set
      finalData <- matrix(0, nrow = length(participant),
                          ncol = length(conditionList))
      
      # give the columns the condition names
      colnames(finalData) <- conditionList
      
      # add the participant column
      finalData <- cbind(participant, finalData)
      
      # convert to data frame
      finalData <- data.frame(finalData)
      
      # intialise looping variable for subjects
      i <- 1
      
      # loop over all subjects
      for(currSub in participant){
        
        # intialise looping variable for conditions. It starts at 2 because the
        # first column in the data file containing condition information is the
        # second one.
        j <- 2
        
        # loop over all conditions
        for(currCond in conditionList){
          
          # get the relevant data
          tempData <- subset(trimmedData, trimmedData$participant == currSub &
                               trimmedData$condition == currCond)
          
          # find the cutoff
          curMean <- mean(tempData$rt)
          curSD <- sd(tempData$rt)
          curCutoff <- curMean + (stDev * curSD)
          
          # trim the data
          curData <- subset(tempData, tempData$rt < curCutoff)
          
          # find the average, and add to the data frame
          finalData[i, j] <- round(median(curData$rt), digits = digits)
          
          # update condition loop counter
          j <- j + 1
        }
        
        # update participant loop counter
        i <- i + 1
      }
      
      return(finalData)
    }
    
    
  } # end of perCell == TRUE & perParticipant == TRUE
  
  
} # end of function

#------------------------------------------------------------------------------

```

``` {r expt1analysis, include=FALSE}

if (doanalysis==1){
#################################
# Exp 1: linguistic noun-verb   #
################################
#open file for linguistic switching task
LS_Exp1 <- read.csv("data/LinguisticSwitching_All.csv")

#### run accuracy analyses first - linguistic noun-verb Exp1 ####
#we are working with DV accuracy01, which just scores accuracy as 0 or 1. Detailed accuracy types are given in "accuracy": 0 = no response; 2 = wrong word; 3 = wrong language; 5 = combination of rules. 1 (correct) and 7 (correct response preceded by incorrect rule trial or break) both count as correct responses.

#### Prepare file for accuracy analysis #### 
#remove first trial after a break in dual-rule part, as trial type cannot be determined 
LS_Exp1 <-  subset(LS_Exp1, LS_Exp1$TrialType != "X")
#contrast code RULE
LS_Exp1$Rule_coded <- as.factor(LS_Exp1$Rule)
LS_Exp1$Rule_coded <- ifelse(LS_Exp1$Rule_coded == "OBJECT", -0.5, ifelse(LS_Exp1$Rule_coded== "ACTION", 0.5, 99))
aggregate(Rule_coded~Rule, data=LS_Exp1, mean, na.rm=TRUE)

#contrast code AGE GROUP
LS_Exp1$Agegroup_coded <- as.factor(LS_Exp1$AgeGroup)
LS_Exp1$Agegroup_coded <- ifelse(LS_Exp1$Agegroup_coded == "Younger", -0.5, ifelse(LS_Exp1$Agegroup_coded== "Older", 0.5, 99))
aggregate(Agegroup_coded~AgeGroup, data=LS_Exp1, mean, na.rm=TRUE)

#### take subset of switch and non-switch trials for switching analysis #### 
LS_Exp1_switching <- subset(LS_Exp1, LS_Exp1$TrialType == "switch" | LS_Exp1$TrialType == "nonswitch")
#contrast code SWITCHING
LS_Exp1_switching$Switching_coded <- as.factor(LS_Exp1_switching$TrialType)
LS_Exp1_switching$Switching_coded <- ifelse(LS_Exp1_switching$Switching_coded == "nonswitch", -0.5, ifelse(LS_Exp1_switching$Switching_coded== "switch", 0.5, 99))
aggregate(Switching_coded~TrialType, data=LS_Exp1_switching, mean, na.rm=TRUE)

#### accuracy analysis - switching ####
#GLME: DV accuracy01, predictors age group, rule, and trial type (switching)

# COMMENTED OUT MODELS THAT DO NOT CONVERGE AND ARE NOT USED IN SUBSEQUENT ANALYSIS
# glme_LS_accSwitching_Exp1<- glmer(accuracy01~ Switching_coded*Agegroup_coded*Rule_coded + (1+Switching_coded*Rule_coded|participant) + (1+Switching_coded*Agegroup_coded*Rule_coded|Image), data = LS_Exp1_switching, family = binomial, control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
# #does not converge, remove correlations
# glme_LS_accSwitching_Exp1_1<- glmer(accuracy01~ Switching_coded*Agegroup_coded*Rule_coded + (1+Switching_coded*Rule_coded||participant) + (1+Switching_coded*Agegroup_coded*Rule_coded||Image), data = LS_Exp1_switching, family = binomial, control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
# #does not converge, remove item slopes for switching, switching x age group, and switching x age group x rule
# glme_LS_accSwitching_Exp1_2<- glmer(accuracy01~ Switching_coded*Agegroup_coded*Rule_coded + (1+Switching_coded*Rule_coded||participant) + (1+Agegroup_coded+Rule_coded+Switching_coded:Rule_coded+Agegroup_coded:Rule_coded||Image), data = LS_Exp1_switching, family = binomial, control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
# #does not converge, remove item slope for rule x switching
# glme_LS_accSwitching_Exp1_3<- glmer(accuracy01~ Switching_coded*Agegroup_coded*Rule_coded + (1+Switching_coded*Rule_coded||participant) + (1+Agegroup_coded+Rule_coded+Agegroup_coded:Rule_coded||Image), data = LS_Exp1_switching, family = binomial, control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
# #does not converge, remove item slope for  age group
# glme_LS_accSwitching_Exp1_4<- glmer(accuracy01~ Switching_coded*Agegroup_coded*Rule_coded + (1+Switching_coded*Rule_coded||participant) + (1+Rule_coded+Agegroup_coded:Rule_coded||Image), data = LS_Exp1_switching, family = binomial, control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
# #does not converge, remove item slope for  rule
# glme_LS_accSwitching_Exp1_5<- glmer(accuracy01~ Switching_coded*Agegroup_coded*Rule_coded + (1+Switching_coded*Rule_coded||participant) + (1+Agegroup_coded:Rule_coded||Image), data = LS_Exp1_switching, family = binomial, control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
# #does not converge, remove item slope for age x rule
# glme_LS_accSwitching_Exp1_6<- glmer(accuracy01~ Switching_coded*Agegroup_coded*Rule_coded + (1+Switching_coded*Rule_coded||participant) + (1|Image), data = LS_Exp1_switching, family = binomial, control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
#does not converge, remove participant slope for switching x rule


glme_LS_accSwitching_Exp1_7<- glmer(accuracy01~ Switching_coded*Agegroup_coded*Rule_coded + (1+Switching_coded+Rule_coded||participant) + (1|Image), data = LS_Exp1_switching, family = binomial, control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
summary(glme_LS_accSwitching_Exp1_7)


#### mixing effect, accuracy ####
#take subset of single-task and non-switch trials for mixing analysis
LS_Exp1_mixing <- subset(LS_Exp1, LS_Exp1$TrialType == "SingleNaming" | LS_Exp1$TrialType == "nonswitch")
#contrast code MIXING
LS_Exp1_mixing$Mixing_coded <- as.factor(LS_Exp1_mixing$TrialType)
LS_Exp1_mixing$Mixing_coded <- ifelse(LS_Exp1_mixing$Mixing_coded == "SingleNaming", -0.5, ifelse(LS_Exp1_mixing$Mixing_coded== "nonswitch", 0.5, 99))
aggregate(Mixing_coded~TrialType, data=LS_Exp1_mixing, mean, na.rm=TRUE)

#### accuracy analysis - mixing ####
#GLME: DV accuracy01, predictors age group, rule, and trial type (mixing)

# COMMENTED OUT MODELS THAT DO NOT CONVERGE AND ARE NOT USED IN SUBSEQUENT ANALYSIS
# glme_LS_accMixing_Exp1<- glmer(accuracy01~ Mixing_coded*Agegroup_coded*Rule_coded + (1+Mixing_coded*Rule_coded|participant) + (1+Mixing_coded*Agegroup_coded*Rule_coded|Image), data = LS_Exp1_mixing, family = binomial, control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
# #does not converge, remove correlations
#glme_LS_accMixing_Exp1_1<- glmer(accuracy01~ Mixing_coded*Agegroup_coded*Rule_coded + (1+Mixing_coded*Rule_coded||participant) + (1+Mixing_coded*Agegroup_coded*Rule_coded||Image), data = LS_Exp1_mixing, family = binomial, control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
#does not converge, remove item slopes for mixing x age 
#glme_LS_accMixing_Exp1_2<- glmer(accuracy01~ Mixing_coded*Agegroup_coded*Rule_coded + (1+Mixing_coded*Rule_coded||participant) + (1+Agegroup_coded+Rule_coded+Mixing_coded+Mixing_coded:Rule_coded+Agegroup_coded:Rule_coded+Mixing_coded:Agegroup_coded:Rule_coded||Image), data = LS_Exp1_mixing, family = binomial, control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
#does not converge, remove item slope for mixing
#glme_LS_accMixing_Exp1_3<- glmer(accuracy01~ Mixing_coded*Agegroup_coded*Rule_coded + (1+Mixing_coded*Rule_coded||participant) + (1+Agegroup_coded+Rule_coded+Mixing_coded:Rule_coded+Agegroup_coded:Rule_coded+Mixing_coded:Agegroup_coded:Rule_coded||Image), data = LS_Exp1_mixing, family = binomial, control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
#does not converge, remove item slopes for mixing x age x rule
glme_LS_accMixing_Exp1_4<- glmer(accuracy01~ Mixing_coded*Agegroup_coded*Rule_coded + (1+Mixing_coded*Rule_coded||participant) + (1+Agegroup_coded+Rule_coded+Mixing_coded:Rule_coded+Agegroup_coded:Rule_coded||Image), data = LS_Exp1_mixing, family = binomial, control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
summary(glme_LS_accMixing_Exp1_4) 


#### reaction time Exp 1 linguistic noun-verb #### 
#### outlier removal steps ####

#keep accurate responses only for RT analysis + exclude trials preceded by break or mistake
LS_Exp1_acc <- subset(LS_Exp1, LS_Exp1$accuracy=="1")

#check distribution raw RT
# hist(LS_Exp1_acc$rt)

#log RT for outlier removal
LS_Exp1_acc$rawrt <-LS_Exp1_acc$rt
LS_Exp1_acc$rt <- log(LS_Exp1_acc$rt)
#check histogram log RT
# hist(LS_Exp1_acc$rt)

#create new condition variable that combines participant, trial type, and rule info
LS_Exp1_acc$condition<-paste0(as.character(LS_Exp1_acc$participant), (LS_Exp1_acc$TrialType), (LS_Exp1_acc$Rule))

#remove RT outliers 2.5 SD below/above mean per participant and condition
LS_Exp1_acc_outliers <- sdTrim(data = LS_Exp1_acc, minRT = 0, sd = 2.5, 
                       perCondition = TRUE, perParticipant = FALSE, 
                       returnType = "raw", digits = 20)

#Check distribution of log RT after outlier removal
# hist(LS_Exp1_acc_outliers$rt)

#Write the trimmed data to a .csv file
# write.csv(LS_Exp1_acc_outliers, "LS_Exp1_acc_outliers.csv")

#### Prepare file for RT analysis ####
#### take subset of switch and non-switch trials for switching analysis #### 
LS_Exp1_acc_outliers_switching <- subset(LS_Exp1_acc_outliers, LS_Exp1_acc_outliers$TrialType == "switch" | LS_Exp1_acc_outliers$TrialType == "nonswitch")
#contrast code SWITCHING
LS_Exp1_acc_outliers_switching$Switching_coded <- as.factor(LS_Exp1_acc_outliers_switching$TrialType)
LS_Exp1_acc_outliers_switching$Switching_coded <- ifelse(LS_Exp1_acc_outliers_switching$Switching_coded == "nonswitch", -0.5, ifelse(LS_Exp1_acc_outliers_switching$Switching_coded== "switch", 0.5, 99))
aggregate(Switching_coded~TrialType, data=LS_Exp1_acc_outliers_switching, mean, na.rm=TRUE)

#### RT analysis - switching ####

# COMMENTED OUT MODELS THAT DO NOT CONVERGE AND ARE NOT USED IN SUBSEQUENT ANALYSIS
# #LME: log RT DV, predictors age group, rule, and trial type (switching)
# lme_LS_Exp1<- lmer(rt~ Switching_coded*Agegroup_coded*Rule_coded + (1+Switching_coded*Rule_coded|participant) + (1+Switching_coded*Agegroup_coded*Rule_coded|Image), REML = TRUE, data = LS_Exp1_acc_outliers_switching,control = lmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
# #does not converge, remove correlations
# lme_LS_Exp1_1<- lmer(rt~ Switching_coded*Agegroup_coded*Rule_coded + (1+Switching_coded*Rule_coded||participant) + (1+Switching_coded*Agegroup_coded*Rule_coded||Image), REML = TRUE, data = LS_Exp1_acc_outliers_switching,control = lmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
# #does not converge. We first remove item slopes explaining the lowest variance, namely switching x age group

lme_LS_Exp1_2<- lmer(rt~ Switching_coded*Agegroup_coded*Rule_coded + (1+Switching_coded*Rule_coded||participant) + (1+Switching_coded+Agegroup_coded+Rule_coded+Switching_coded:Rule_coded+Agegroup_coded:Rule_coded+Switching_coded:Rule_coded:Agegroup_coded||Image), REML = TRUE, data = LS_Exp1_acc_outliers_switching,control = lmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
summary(lme_LS_Exp1_2)

#### take subset of switch and non-switch trials for mixing analysis #### 
#take subset of single-task and non-switch trials for mixing analysis
LS_Exp1_acc_outliers_mixing <- subset(LS_Exp1_acc_outliers, LS_Exp1_acc_outliers$TrialType == "SingleNaming" | LS_Exp1_acc_outliers$TrialType == "nonswitch")
#contrast code MIXING
LS_Exp1_acc_outliers_mixing$Mixing_coded <- as.factor(LS_Exp1_acc_outliers_mixing$TrialType)
LS_Exp1_acc_outliers_mixing$Mixing_coded <- ifelse(LS_Exp1_acc_outliers_mixing$Mixing_coded == "SingleNaming", -0.5, ifelse(LS_Exp1_acc_outliers_mixing$Mixing_coded== "nonswitch", 0.5, 99))
aggregate(Mixing_coded~TrialType, data=LS_Exp1_acc_outliers_mixing, mean, na.rm=TRUE)

#### RT analysis - mixing ####

# COMMENTED OUT MODELS THAT DO NOT CONVERGE AND ARE NOT USED IN SUBSEQUENT ANALYSIS
# #LME: log RT DV, predictors age group, rule, and trial type (mixing)
# lme_LS_Exp1_mixing <- lmer(rt~ Mixing_coded*Agegroup_coded*Rule_coded + (1+Mixing_coded*Rule_coded|participant) + (1+Mixing_coded*Agegroup_coded*Rule_coded|Image), REML = TRUE, data = LS_Exp1_acc_outliers_mixing,control = lmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
# #does not converge, remove correlations

lme_LS_Exp1_mixing_1 <- lmer(rt~ Mixing_coded*Agegroup_coded*Rule_coded + (1+Mixing_coded*Rule_coded||participant) + (1+Mixing_coded*Agegroup_coded*Rule_coded||Image), REML = TRUE, data = LS_Exp1_acc_outliers_mixing,control = lmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
summary(lme_LS_Exp1_mixing_1)

########################################
# NON-Linguistic switching task - EXP1 #
#######################################
#open file for non-linguistic switching task
NLS_Exp1 <- read.csv("data/NonLinguisticSwitching_All.csv")

#### run accuracy analyses first - non-linguistic Exp1 ####
#we are working with DV accuracy01, which just scores accuracy as 0 or 1. 1 (correct) and 7 (correct response preceded by incorrect trial or break) both count as correct responses.

#### Prepare file for accuracy analysis #### 
#remove first trial after a break in dual-rule part, as trial type cannot be determined 
NLS_Exp1 <-  subset(NLS_Exp1, NLS_Exp1$TrialType != "X")

#contrast code RULE
NLS_Exp1$Rule_coded <- as.factor(NLS_Exp1$Rule)
NLS_Exp1$Rule_coded <- ifelse(NLS_Exp1$Rule_coded == "SIZE", -0.5, ifelse(NLS_Exp1$Rule_coded== "PARITY", 0.5, 99))
aggregate(Rule_coded~Rule, data=NLS_Exp1, mean, na.rm=TRUE)

#contrast code AGE GROUP
NLS_Exp1$Agegroup_coded <- as.factor(NLS_Exp1$AgeGroup)
NLS_Exp1$Agegroup_coded <- ifelse(NLS_Exp1$Agegroup_coded == "Younger", -0.5, ifelse(NLS_Exp1$Agegroup_coded== "Older", 0.5, 99))
aggregate(Agegroup_coded~AgeGroup, data=NLS_Exp1, mean, na.rm=TRUE)


#### take subset of switch and non-switch trials for switching analysis #### 
NLS_Exp1_switching <- subset(NLS_Exp1, NLS_Exp1$TrialType == "switch" | NLS_Exp1$TrialType == "nonswitch")
#contrast code SWITCHING
NLS_Exp1_switching$Switching_coded <- as.factor(NLS_Exp1_switching$TrialType)
NLS_Exp1_switching$Switching_coded <- ifelse(NLS_Exp1_switching$Switching_coded == "nonswitch", -0.5, ifelse(NLS_Exp1_switching$Switching_coded== "switch", 0.5, 99))
aggregate(Switching_coded~TrialType, data=NLS_Exp1_switching, mean, na.rm=TRUE)


#GLME: DV accuracy01, predictors age group, rule, and trial type (switching)

# COMMENTED OUT MODELS THAT DO NOT CONVERGE AND ARE NOT USED IN SUBSEQUENT ANALYSIS

#full model does not converge and takes a very long time to run, so not including this for now
#glme_NLS_accSwitching_Exp1<- glmer(accuracy01~ Switching_coded*Agegroup_coded*Rule_coded + (1+Switching_coded*Rule_coded|participant) + (1+Switching_coded*Agegroup_coded*Rule_coded|Item), data = NLS_Exp1_switching, family = binomial, control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
#does not converge, so remove correlations
# glme_NLS_accSwitching_Exp1_1<- glmer(accuracy01~ Switching_coded*Agegroup_coded*Rule_coded + (1+Switching_coded*Rule_coded||participant) + (1+Switching_coded*Agegroup_coded*Rule_coded||Item), data = NLS_Exp1_switching, family = binomial, control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
# #does not converge, so remove item slope for switching x age x rule
# glme_NLS_accSwitching_Exp1_2<- glmer(accuracy01~ Switching_coded*Agegroup_coded*Rule_coded + (1+Switching_coded*Rule_coded||participant) + (1+Switching_coded+Agegroup_coded+Rule_coded+Switching_coded:Agegroup_coded+Agegroup_coded:Rule_coded+Switching_coded:Rule_coded||Item), data = NLS_Exp1_switching, family = binomial, control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
# #does not converge, so remove item slope for Age group
# glme_NLS_accSwitching_Exp1_3<- glmer(accuracy01~ Switching_coded*Agegroup_coded*Rule_coded + (1+Switching_coded*Rule_coded||participant) + (1+Switching_coded+Rule_coded+Switching_coded:Agegroup_coded+Agegroup_coded:Rule_coded+Switching_coded:Rule_coded||Item), data = NLS_Exp1_switching, family = binomial, control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
# #does not converge, so remove item slope for Switching x Age group
# glme_NLS_accSwitching_Exp1_4<- glmer(accuracy01~ Switching_coded*Agegroup_coded*Rule_coded + (1+Switching_coded*Rule_coded||participant) + (1+Switching_coded+Rule_coded+Agegroup_coded:Rule_coded+Switching_coded:Rule_coded||Item), data = NLS_Exp1_switching, family = binomial, control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
# #does not converge, so remove item slope for Rule x Age group
# glme_NLS_accSwitching_Exp1_5<- glmer(accuracy01~ Switching_coded*Agegroup_coded*Rule_coded + (1+Switching_coded*Rule_coded||participant) + (1+Switching_coded+Rule_coded+Switching_coded:Rule_coded||Item), data = NLS_Exp1_switching, family = binomial, control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
# #does not converge, so remove item slope for switching
# glme_NLS_accSwitching_Exp1_6<- glmer(accuracy01~ Switching_coded*Agegroup_coded*Rule_coded + (1+Switching_coded*Rule_coded||participant) + (1+Rule_coded+Switching_coded:Rule_coded||Item), data = NLS_Exp1_switching, family = binomial, control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
# #does not converge, so remove item slope for rule
# glme_NLS_accSwitching_Exp1_7<- glmer(accuracy01~ Switching_coded*Agegroup_coded*Rule_coded + (1+Switching_coded*Rule_coded||participant) + (1+Switching_coded:Rule_coded||Item), data = NLS_Exp1_switching, family = binomial, control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
# #does not converge, so remove item slope for rule x switching
# glme_NLS_accSwitching_Exp1_8<- glmer(accuracy01~ Switching_coded*Agegroup_coded*Rule_coded + (1+Switching_coded*Rule_coded||participant) + (1|Item), data = NLS_Exp1_switching, family = binomial, control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
# #does not converge, so remove participant slope for Switching x rule
# glme_NLS_accSwitching_Exp1_9<- glmer(accuracy01~ Switching_coded*Agegroup_coded*Rule_coded + (1+Switching_coded+Rule_coded||participant) + (1|Item), data = NLS_Exp1_switching, family = binomial, control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
# #does not converge, so remove participant slope for Switching 

glme_NLS_accSwitching_Exp1_10<- glmer(accuracy01~ Switching_coded*Agegroup_coded*Rule_coded + (1+Rule_coded||participant) + (1|Item), data = NLS_Exp1_switching, family = binomial, control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
summary(glme_NLS_accSwitching_Exp1_10)

#### take subset of single-task and non-switch trials for mixing analysis ####
NLS_Exp1_mixing <- subset(NLS_Exp1, NLS_Exp1$TrialType == "SingleNaming" | NLS_Exp1$TrialType == "nonswitch")
#contrast code MIXING
NLS_Exp1_mixing$Mixing_coded <- as.factor(NLS_Exp1_mixing$TrialType)
NLS_Exp1_mixing$Mixing_coded <- ifelse(NLS_Exp1_mixing$Mixing_coded == "SingleNaming", -0.5, ifelse(NLS_Exp1_mixing$Mixing_coded== "nonswitch", 0.5, 99))
aggregate(Mixing_coded~TrialType, data=NLS_Exp1_mixing, mean, na.rm=TRUE)

#GLME: DV accuracy01, predictors age group, rule, and trial type (mixing)
# COMMENTED OUT MODELS THAT DO NOT CONVERGE AND ARE NOT USED IN SUBSEQUENT ANALYSIS

#full model does not converge and takes a very long time to run, so not including this for now
#glme_NLS_accMixing_Exp1<- glmer(accuracy01~ Mixing_coded*Agegroup_coded*Rule_coded + (1+Mixing_coded*Rule_coded|participant) + (1+Mixing_coded*Agegroup_coded*Rule_coded|Item), data = NLS_Exp1_mixing, family = binomial, control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
#does not converge, so remove correlations
# glme_NLS_accMixing_Exp1_1<- glmer(accuracy01~ Mixing_coded*Agegroup_coded*Rule_coded + (1+Mixing_coded*Rule_coded||participant) + (1+Mixing_coded*Agegroup_coded*Rule_coded||Item), data = NLS_Exp1_mixing, family = binomial, control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
# #does not converge, so remove item slope for mixing x age x rule
glme_NLS_accMixing_Exp1_2<- glmer(accuracy01~ Mixing_coded*Agegroup_coded*Rule_coded + (1+Mixing_coded*Rule_coded||participant) + (1+Mixing_coded+Agegroup_coded+Rule_coded+Mixing_coded:Agegroup_coded+Rule_coded:Mixing_coded+Rule_coded:Agegroup_coded||Item), data = NLS_Exp1_mixing, family = binomial, control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
summary(glme_NLS_accMixing_Exp1_2)


#### reaction time Exp 1 non-linguistic #### 
#### outlier removal steps ####

#keep accurate responses only
NLS_Exp1_acc<- subset(NLS_Exp1, NLS_Exp1$accuracy=="1")

#check distribution raw RT
# hist(NLS_Exp1_acc$rawrt)

#log RT for outlier removal
NLS_Exp1_acc$rt = log(NLS_Exp1_acc$rawrt)
#check histogram log RT
# hist(NLS_Exp1_acc$rt)

#create new condition variable that combines participant, trial type, and rule info
NLS_Exp1_acc$condition<-paste0(as.character(NLS_Exp1_acc$participant), (NLS_Exp1_acc$TrialType), (NLS_Exp1_acc$Rule))

#remove outliers 2.5 SD below/above mean per participant and condition
NLS_Exp1_acc_outliers <- sdTrim(data = NLS_Exp1_acc, minRT = 0, sd = 2.5, 
                               perCondition = TRUE, perParticipant = FALSE, 
                               returnType = "raw", digits = 20)

#Check distribution of log RT after outlier removal
# hist(NLS_Exp1_acc_outliers$rt)

#Write the trimmed data to a .csv file
# write.csv(NLS_Exp1_acc_outliers, "NLS_Exp1_acc_outliers.csv")

#### Prepare file for RT analysis ####
#take subset of switch and non-switch trials for switching analysis
NLS_Exp1_acc_outliers_switching <- subset(NLS_Exp1_acc_outliers, NLS_Exp1_acc_outliers$TrialType == "switch" | NLS_Exp1_acc_outliers$TrialType == "nonswitch")
#contrast code SWITCHING
NLS_Exp1_acc_outliers_switching$Switching_coded = as.factor(NLS_Exp1_acc_outliers_switching$TrialType)
NLS_Exp1_acc_outliers_switching$Switching_coded <- ifelse(NLS_Exp1_acc_outliers_switching$Switching_coded == "nonswitch", -0.5, ifelse(NLS_Exp1_acc_outliers_switching$Switching_coded== "switch", 0.5, 99))
aggregate(Switching_coded~TrialType, data=NLS_Exp1_acc_outliers_switching, mean, na.rm=TRUE)

#### RT analysis - switching ####
# COMMENTED OUT MODELS THAT DO NOT CONVERGE AND ARE NOT USED IN SUBSEQUENT ANALYSIS

# #LME: log RT DV, predictors age group, rule, and trial type (switching)
# lme_NLS_Exp1= lmer(rt~ Switching_coded*Agegroup_coded*Rule_coded + (1+Switching_coded*Rule_coded|participant) + (1+Switching_coded*Agegroup_coded*Rule_coded|Item), REML = TRUE, data = NLS_Exp1_acc_outliers_switching,control = lmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
# #does not converge, remove correlations
# lme_NLS_Exp1_1= lmer(rt~ Switching_coded*Agegroup_coded*Rule_coded + (1+Switching_coded*Rule_coded||participant) + (1+Switching_coded*Agegroup_coded*Rule_coded||Item), REML = TRUE, data = NLS_Exp1_acc_outliers_switching,control = lmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
# #does not converge, remove item slope for switching x age x rule

lme_NLS_Exp1_2= lmer(rt~ Switching_coded*Agegroup_coded*Rule_coded + (1+Switching_coded*Rule_coded||participant) + (1+Switching_coded+Agegroup_coded+Rule_coded+Switching_coded:Agegroup_coded+Rule_coded:Agegroup_coded+Switching_coded:Rule_coded||Item), REML = TRUE, data = NLS_Exp1_acc_outliers_switching,control = lmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
summary(lme_NLS_Exp1_2)

#check analysis without 3 participants scoring below 70% accuracy
NLS_Exp1_acc_outliers_switching_minus3<- subset(NLS_Exp1_acc_outliers_switching, NLS_Exp1_acc_outliers_switching$participant!="30" & NLS_Exp1_acc_outliers_switching$participant!="49" & NLS_Exp1_acc_outliers_switching$participant!="64")
lme_NLS_Exp1_2_minus3= lmer(rt~ Switching_coded*Agegroup_coded*Rule_coded + (1+Switching_coded*Rule_coded||participant) + (1+Switching_coded+Agegroup_coded+Rule_coded+Switching_coded:Agegroup_coded+Rule_coded:Agegroup_coded+Switching_coded:Rule_coded||Item), REML = TRUE, data = NLS_Exp1_acc_outliers_switching_minus3,control = lmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))

#next analysis is on mixing effect
#### take subset of single-task and non-switch trials for mixing analysis ####
NLS_Exp1_acc_outliers_mixing <- subset(NLS_Exp1_acc_outliers, NLS_Exp1_acc_outliers$TrialType == "SingleNaming" | NLS_Exp1_acc_outliers$TrialType == "nonswitch")
#contrast code MIXING
NLS_Exp1_acc_outliers_mixing$Mixing_coded = as.factor(NLS_Exp1_acc_outliers_mixing$TrialType)
NLS_Exp1_acc_outliers_mixing$Mixing_coded <- ifelse(NLS_Exp1_acc_outliers_mixing$Mixing_coded == "SingleNaming", -0.5, ifelse(NLS_Exp1_acc_outliers_mixing$Mixing_coded== "nonswitch", 0.5, 99))
aggregate(Mixing_coded~TrialType, data=NLS_Exp1_acc_outliers_mixing, mean, na.rm=TRUE)

#### RT analysis - mixing ####
# COMMENTED OUT MODELS THAT DO NOT CONVERGE AND ARE NOT USED IN SUBSEQUENT ANALYSIS

# #LME: log RT DV, predictors age group, rule, and trial type (mixing)
# lme_NLS_Exp1_mixing= lmer(rt~ Mixing_coded*Agegroup_coded*Rule_coded + (1+Mixing_coded*Rule_coded|participant) + (1+Mixing_coded*Agegroup_coded*Rule_coded|Item), REML = TRUE, data = NLS_Exp1_acc_outliers_mixing,control = lmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
# #does not converge, remove correlations
# lme_NLS_Exp1_mixing_1= lmer(rt~ Mixing_coded*Agegroup_coded*Rule_coded + (1+Mixing_coded*Rule_coded||participant) + (1+Mixing_coded*Agegroup_coded*Rule_coded||Item), REML = TRUE, data = NLS_Exp1_acc_outliers_mixing,control = lmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
#does not converge, remove item slopes for age x rule & mixing x age
lme_NLS_Exp1_mixing_2= lmer(rt~ Mixing_coded*Agegroup_coded*Rule_coded + (1+Mixing_coded*Rule_coded||participant) + (1+Mixing_coded+Agegroup_coded+Rule_coded+Mixing_coded:Rule_coded+Mixing_coded:Agegroup_coded:Rule_coded||Item), REML = TRUE, data = NLS_Exp1_acc_outliers_mixing,control = lmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
summary(lme_NLS_Exp1_mixing_2) #updated model in new R version

#check analysis without 3 participants scoring below 70% accuracy
NLS_Exp1_acc_outliers_mixing_minus3<- subset(NLS_Exp1_acc_outliers_mixing, NLS_Exp1_acc_outliers_mixing$participant!="30" & NLS_Exp1_acc_outliers_mixing$participant!="49" & NLS_Exp1_acc_outliers_mixing$participant!="64")
lme_NLS_Exp1_mixing_3_minus3= lmer(rt~ Mixing_coded*Agegroup_coded*Rule_coded + (1+Mixing_coded*Rule_coded||participant) + (1+Mixing_coded+Agegroup_coded+Rule_coded+Mixing_coded:Rule_coded+Mixing_coded:Agegroup_coded:Rule_coded||Item), REML = TRUE, data = NLS_Exp1_acc_outliers_mixing_minus3,control = lmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))


#### final checks with z-scored non-linguistic RTs, to address opposite age effect in log RTs vs untransformed RTs ####
NLS_Exp1_acc_outliers_mixing = NLS_Exp1_acc_outliers_mixing %>%
  group_by(participant) %>%
  mutate(z_score = scale(rawrt))

#remove participant intercept because of z-scoring
#same model as above does not converge, but no longer shows age x mixing effect with z-scored RTs
#lme_NLS_Exp1_mixing_2_zscore= lmer(z_score~ Mixing_coded*Agegroup_coded*Rule_coded + (0+Mixing_coded*Rule_coded||participant) + (1+Mixing_coded+Agegroup_coded+Rule_coded+Mixing_coded:Rule_coded+Mixing_coded:Agegroup_coded:Rule_coded||Item), REML = TRUE, data = NLS_Exp1_acc_outliers_mixing,control = lmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
#remove item slope for age group and mixing x age group x rule
lme_NLS_Exp1_mixing_2_zscore_conv= lmer(z_score~ Mixing_coded*Agegroup_coded*Rule_coded + (0+Mixing_coded*Rule_coded||participant) + (1+Mixing_coded+Rule_coded+Mixing_coded:Rule_coded||Item), REML = TRUE, data = NLS_Exp1_acc_outliers_mixing,control = lmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))


}

```

``` {r expt2analysis, include=FALSE}

if (doanalysis==1){
#################################
# EXPERIMENT 2                 #
################################

#################################
# BILINGUAL switching task     #
################################
#open file for linguistic switching task
Bilingual_Exp2 <- read.csv("data/Exp2_Bilingual.csv")

#### run accuracy analyses first - bilingual Exp2 ####
#we are working with DV accuracy01, which just scores accuracy as 0 or 1. Detailed accuracy types are given in "accuracy": 0 = no response; 2 = wrong word; 3 = wrong language; 5 = combination of languages. 1 (correct) and 7 (correct response preceded by incorrect language trial or break) both count as correct responses.

#### Prepare file for accuracy analysis #### 
#remove first trial after a break in dual-rule part, as trial type cannot be determined 
Bilingual_Exp2 <-  subset(Bilingual_Exp2, Bilingual_Exp2$Trialtype != "X")

#contrast code LANGUAGE
Bilingual_Exp2$Language_coded = as.factor(Bilingual_Exp2$Language)
Bilingual_Exp2$Language_coded <- ifelse(Bilingual_Exp2$Language_coded == "L1", -0.5, ifelse(Bilingual_Exp2$Language_coded== "L2", 0.5, 99))
aggregate(Language_coded~Language, data=Bilingual_Exp2, mean, na.rm=TRUE)

#contrast code AGE GROUP
Bilingual_Exp2$Agegroup_coded = as.factor(Bilingual_Exp2$Agegroup)
Bilingual_Exp2$Agegroup_coded <- ifelse(Bilingual_Exp2$Agegroup_coded == "Younger", -0.5, ifelse(Bilingual_Exp2$Agegroup_coded== "Older", 0.5, 99))
aggregate(Agegroup_coded~Agegroup, data=Bilingual_Exp2, mean, na.rm=TRUE)

#take subset of switch and non-switch trials for switching analysis
Bilingual_Exp2_switching <- subset(Bilingual_Exp2, Bilingual_Exp2$Trialtype == "switch" | Bilingual_Exp2$Trialtype == "nonswitch")
#contrast code SWITCHING
Bilingual_Exp2_switching$Switching_coded = as.factor(Bilingual_Exp2_switching$Trialtype)
Bilingual_Exp2_switching$Switching_coded <- ifelse(Bilingual_Exp2_switching$Switching_coded == "nonswitch", -0.5, ifelse(Bilingual_Exp2_switching$Switching_coded== "switch", 0.5, 99))
aggregate(Switching_coded~Trialtype, data=Bilingual_Exp2_switching, mean, na.rm=TRUE)

#### accuracy analysis - switching ####
# COMMENTED OUT MODELS THAT DO NOT CONVERGE AND ARE NOT USED IN SUBSEQUENT ANALYSIS
#GLME: DV accuracy01, predictors age group, rule, and trial type (switching)
#glme_Bilingual_accSwitching_Exp2= glmer(accuracy01~ Switching_coded*Agegroup_coded*Language_coded + (1+Switching_coded*Language_coded|participant) + (1+Switching_coded*Agegroup_coded*Language_coded|Item), data = Bilingual_Exp2_switching, family = binomial,control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
#does not converge, remove correlations
# glme_Bilingual_accSwitching_Exp2_1= glmer(accuracy01~ Switching_coded*Agegroup_coded*Language_coded + (1+Switching_coded*Language_coded||participant) + (1+Switching_coded*Agegroup_coded*Language_coded||Item), data = Bilingual_Exp2_switching, family = binomial,control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
#does not converge, remove item slopes for switching, switching x age, switching x language, and switching x language x age
# glme_Bilingual_accSwitching_Exp2_2= glmer(accuracy01~ Switching_coded*Agegroup_coded*Language_coded + (1+Switching_coded*Language_coded||participant) + (1+Agegroup_coded+Language_coded+Agegroup_coded:Language_coded||Item), data = Bilingual_Exp2_switching, family = binomial,control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
#does not converge, remove item slope for age 
# glme_Bilingual_accSwitching_Exp2_3= glmer(accuracy01~ Switching_coded*Agegroup_coded*Language_coded + (1+Switching_coded*Language_coded||participant) + (1+Language_coded+Agegroup_coded:Language_coded||Item), data = Bilingual_Exp2_switching, family = binomial,control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
#does not converge, remove item slope for age x language
# glme_Bilingual_accSwitching_Exp2_4= glmer(accuracy01~ Switching_coded*Agegroup_coded*Language_coded + (1+Switching_coded*Language_coded||participant) + (1+Language_coded||Item), data = Bilingual_Exp2_switching, family = binomial,control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
#does not converge, remove item slope for  language
# glme_Bilingual_accSwitching_Exp2_5= glmer(accuracy01~ Switching_coded*Agegroup_coded*Language_coded + (1+Switching_coded*Language_coded||participant) + (1|Item), data = Bilingual_Exp2_switching, family = binomial,control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
#does not converge, remove participant slope for switching x language
# glme_Bilingual_accSwitching_Exp2_6= glmer(accuracy01~ Switching_coded*Agegroup_coded*Language_coded + (1+Switching_coded+Language_coded||participant) + (1|Item), data = Bilingual_Exp2_switching, family = binomial,control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
#does not converge, remove participant slope for switching 
glme_Bilingual_accSwitching_Exp2_7= glmer(accuracy01~ Switching_coded*Agegroup_coded*Language_coded + (1+Language_coded||participant) + (1|Item), data = Bilingual_Exp2_switching, family = binomial,control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
summary(glme_Bilingual_accSwitching_Exp2_7)

#### next analysis is on mixing effect ####
#take subset of single-task and non-switch trials for mixing analysis
Bilingual_Exp2_mixing <- subset(Bilingual_Exp2, Bilingual_Exp2$Trialtype == "SingleNaming" | Bilingual_Exp2$Trialtype == "nonswitch")
#contrast code MIXING
Bilingual_Exp2_mixing$Mixing_coded = as.factor(Bilingual_Exp2_mixing$Trialtype)
Bilingual_Exp2_mixing$Mixing_coded <- ifelse(Bilingual_Exp2_mixing$Mixing_coded == "SingleNaming", -0.5, ifelse(Bilingual_Exp2_mixing$Mixing_coded== "nonswitch", 0.5, 99))
aggregate(Mixing_coded~Trialtype, data=Bilingual_Exp2_mixing, mean, na.rm=TRUE)

#### accuracy analysis - mixing ####
# COMMENTED OUT MODELS THAT DO NOT CONVERGE AND ARE NOT USED IN SUBSEQUENT ANALYSIS
#GLME: DV accuracy01, predictors age group, rule, and trial type (mixing)
#glme_Bilingual_accMixing_Exp2= glmer(accuracy01~ Mixing_coded*Agegroup_coded*Language_coded + (1+Mixing_coded*Language_coded|participant) + (1+Mixing_coded*Agegroup_coded*Language_coded|Item), data = Bilingual_Exp2_mixing, family = binomial,control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
#does not converge, remove correlations
#glme_Bilingual_accMixing_Exp2_1= glmer(accuracy01~ Mixing_coded*Agegroup_coded*Language_coded + (1+Mixing_coded*Language_coded||participant) + (1+Mixing_coded*Agegroup_coded*Language_coded||Item), data = Bilingual_Exp2_mixing, family = binomial,control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
#does not converge, remove item slope for mixing x language + mixing x age group x language
#glme_Bilingual_accMixing_Exp2_2= glmer(accuracy01~ Mixing_coded*Agegroup_coded*Language_coded + (1+Mixing_coded*Language_coded||participant) + (1+Mixing_coded+Agegroup_coded+Language_coded+Mixing_coded:Agegroup_coded+Agegroup_coded:Language_coded||Item), data = Bilingual_Exp2_mixing, family = binomial,control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
#does not converge, remove item slope for mixing
glme_Bilingual_accMixing_Exp2_3= glmer(accuracy01~ Mixing_coded*Agegroup_coded*Language_coded + (1+Mixing_coded*Language_coded||participant) + (1+Agegroup_coded+Language_coded+Mixing_coded:Agegroup_coded+Agegroup_coded:Language_coded||Item), data = Bilingual_Exp2_mixing, family = binomial,control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
summary(glme_Bilingual_accMixing_Exp2_3)


#### reaction time Exp 2 bilingual #### 
#### outlier removal steps ####

#keep accurate responses only & remove trials preceded by break or wrong rule
Bilingual_Exp2_acc<- subset(Bilingual_Exp2, Bilingual_Exp2$accuracy=="1")

#check distribution raw RT
Bilingual_Exp2_acc$rt <- as.numeric(as.character(Bilingual_Exp2_acc$rt))
#hist(Bilingual_Exp2_acc$rt)

#log RT for outlier removal
Bilingual_Exp2_acc$rawrt <-Bilingual_Exp2_acc$rt
Bilingual_Exp2_acc$rt <- log(Bilingual_Exp2_acc$rt)
#check histogram log RT
#hist(Bilingual_Exp2_acc$rt)

#create new condition variable that combines participant, trial type, and language info
Bilingual_Exp2_acc$condition<-paste0(as.character(Bilingual_Exp2_acc$participant), (Bilingual_Exp2_acc$Trialtype), (Bilingual_Exp2_acc$Language))

#remove outliers 2.5 SD below/above mean per participant and condition
Bilingual_Exp2_acc_outliers <- sdTrim(data = Bilingual_Exp2_acc, minRT = 0, sd = 2.5, 
                       perCondition = TRUE, perParticipant = FALSE, 
                       returnType = "raw", digits = 20)

#Check distribution of log RT after outlier removal
#hist(Bilingual_Exp2_acc_outliers$rt)

#Write the trimmed data to a .csv file
write.csv(Bilingual_Exp2_acc_outliers, "data/Bilingual_Exp2_acc_outliers.csv")

#Prepare file for RT analysis

#### Prepare file for RT analysis ####
#### take subset of switch and non-switch trials for switching analysis #### 
Bilingual_Exp2_acc_outliers_switching <- subset(Bilingual_Exp2_acc_outliers, Bilingual_Exp2_acc_outliers$Trialtype == "switch" | Bilingual_Exp2_acc_outliers$Trialtype == "nonswitch")
#contrast code SWITCHING
Bilingual_Exp2_acc_outliers_switching$Switching_coded = as.factor(Bilingual_Exp2_acc_outliers_switching$Trialtype)
Bilingual_Exp2_acc_outliers_switching$Switching_coded <- ifelse(Bilingual_Exp2_acc_outliers_switching$Switching_coded == "nonswitch", -0.5, ifelse(Bilingual_Exp2_acc_outliers_switching$Switching_coded== "switch", 0.5, 99))
aggregate(Switching_coded~Trialtype, data=Bilingual_Exp2_acc_outliers_switching, mean, na.rm=TRUE)

#### RT analysis - switching ####
# COMMENTED OUT MODELS THAT DO NOT CONVERGE AND ARE NOT USED IN SUBSEQUENT ANALYSIS
#LME: log RT DV, predictors age group, language, and trial type (switching)
#lme_Bilingual_Exp2= lmer(rt~ Switching_coded*Agegroup_coded*Language_coded + (1+Switching_coded*Language_coded|participant) + (1+Switching_coded*Agegroup_coded*Language_coded|Item), REML = TRUE, data = Bilingual_Exp2_acc_outliers_switching,control = lmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
#does not converge, remove correlations
lme_Bilingual_Exp2_1= lmer(rt~ Switching_coded*Agegroup_coded*Language_coded + (1+Switching_coded*Language_coded||participant) + (1+Switching_coded*Agegroup_coded*Language_coded||Item), REML = TRUE, data = Bilingual_Exp2_acc_outliers_switching,control = lmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
summary(lme_Bilingual_Exp2_1)

#### take subset of switch and non-switch trials for mixing analysis #### 
Bilingual_Exp2_acc_outliers_mixing <- subset(Bilingual_Exp2_acc_outliers, Bilingual_Exp2_acc_outliers$Trialtype == "SingleNaming" | Bilingual_Exp2_acc_outliers$Trialtype == "nonswitch")
#contrast code MIXING
Bilingual_Exp2_acc_outliers_mixing$Mixing_coded = as.factor(Bilingual_Exp2_acc_outliers_mixing$Trialtype)
Bilingual_Exp2_acc_outliers_mixing$Mixing_coded <- ifelse(Bilingual_Exp2_acc_outliers_mixing$Mixing_coded == "SingleNaming", -0.5, ifelse(Bilingual_Exp2_acc_outliers_mixing$Mixing_coded== "nonswitch", 0.5, 99))
aggregate(Mixing_coded~Trialtype, data=Bilingual_Exp2_acc_outliers_mixing, mean, na.rm=TRUE)

#### RT analysis - mixing ####
# COMMENTED OUT MODELS THAT DO NOT CONVERGE AND ARE NOT USED IN SUBSEQUENT ANALYSIS
#LME: log RT DV, predictors age group, rule, and trial type (mixing)
#lme_Bilingual_Exp2_mixing= lmer(rt~ Mixing_coded*Agegroup_coded*Language_coded + (1+Mixing_coded*Language_coded|participant) + (1+Mixing_coded*Agegroup_coded*Language_coded|Item), REML = TRUE, data = Bilingual_Exp2_acc_outliers_mixing,control = lmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
#does not converge, remove correlations
lme_Bilingual_Exp2_mixing_1= lmer(rt~ Mixing_coded*Agegroup_coded*Language_coded + (1+Mixing_coded*Language_coded||participant) + (1+Mixing_coded*Agegroup_coded*Language_coded||Item), REML = TRUE, data = Bilingual_Exp2_acc_outliers_mixing,control = lmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
summary(lme_Bilingual_Exp2_mixing_1)

#### final checks with z-scored bilingual RT, given that there was a main effect of age on overall RTs ####
#start with mixing
Bilingual_Exp2_acc_outliers_mixing = Bilingual_Exp2_acc_outliers_mixing %>%
  group_by(participant) %>%
  mutate(z_score = scale(rawrt))

#remove participant intercept as they are z-scored
#first model does not converge, but shows same pattern as converging model
#lme_Bilingual_Exp2_mixing_1_zscore= lmer(z_score~ Mixing_coded*Agegroup_coded*Language_coded + (0+Mixing_coded*Language_coded||participant) + (1+Mixing_coded*Agegroup_coded*Language_coded||Item), REML = TRUE, data = Bilingual_Exp2_acc_outliers_mixing,control = lmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
#converge after removing item slope for mixing x age x language
lme_Bilingual_Exp2_mixing_zscore_1= lmer(z_score~ Mixing_coded*Agegroup_coded*Language_coded + (0+Mixing_coded*Language_coded||participant) + (1+Mixing_coded+Agegroup_coded+Language_coded+Mixing_coded:Agegroup_coded+Mixing_coded:Language_coded+Agegroup_coded:Language_coded||Item), REML = TRUE, data = Bilingual_Exp2_acc_outliers_mixing,control = lmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))

#same for switching
Bilingual_Exp2_acc_outliers_switching = Bilingual_Exp2_acc_outliers_switching %>%
  group_by(participant) %>%
  mutate(z_score = scale(rawrt))
#remove participant intercept
lme_Bilingual_Exp2_switching_1_zscore= lmer(z_score~ Switching_coded*Agegroup_coded*Language_coded + (0+Switching_coded*Language_coded||participant) + (1+Switching_coded*Agegroup_coded*Language_coded||Item), REML = TRUE, data = Bilingual_Exp2_acc_outliers_switching,control = lmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))


#################################
# Noun-verb switching task Exp 2 #
################################
#open file for linguistic switching task
NounVerb_Exp2 <- read.csv("data/Exp2_NounVerb.csv")

#### run accuracy analyses first - linguistic noun-verb Exp1 ####
#we are working with DV accuracy01, which just scores accuracy as 0 or 1. Detailed accuracy types are given in "accuracy": 0 = no response; 2 = wrong word; 3 = wrong rule; 5 = combination of rules. 1 (correct) and 7 (correct response preceded by incorrect rule or break) both count as correct responses.

#### Prepare file for accuracy analysis #### 
#remove first trial after a break in dual-rule part, as trial type cannot be determined 
NounVerb_Exp2 <-  subset(NounVerb_Exp2, NounVerb_Exp2$TrialType != "X")

#contrast code RULE
NounVerb_Exp2$Rule_coded = as.factor(NounVerb_Exp2$Rule)
NounVerb_Exp2$Rule_coded <- ifelse(NounVerb_Exp2$Rule_coded == "OBJECT", -0.5, ifelse(NounVerb_Exp2$Rule_coded== "ACTION", 0.5, 99))
aggregate(Rule_coded~Rule, data=NounVerb_Exp2, mean, na.rm=TRUE)

#contrast code AGE GROUP
NounVerb_Exp2$Agegroup_coded = as.factor(NounVerb_Exp2$Agegroup)
NounVerb_Exp2$Agegroup_coded <- ifelse(NounVerb_Exp2$Agegroup_coded == "Younger", -0.5, ifelse(NounVerb_Exp2$Agegroup_coded== "Older", 0.5, 99))
aggregate(Agegroup_coded~Agegroup, data=NounVerb_Exp2, mean, na.rm=TRUE)


#take subset of switch and non-switch trials for switching analysis
NounVerb_Exp2_switching <- subset(NounVerb_Exp2, NounVerb_Exp2$TrialType == "switch" | NounVerb_Exp2$TrialType == "nonswitch")
#contrast code SWITCHING
NounVerb_Exp2_switching$Switching_coded = as.factor(NounVerb_Exp2_switching$TrialType)
NounVerb_Exp2_switching$Switching_coded <- ifelse(NounVerb_Exp2_switching$Switching_coded == "nonswitch", -0.5, ifelse(NounVerb_Exp2_switching$Switching_coded== "switch", 0.5, 99))
aggregate(Switching_coded~TrialType, data=NounVerb_Exp2_switching, mean, na.rm=TRUE)

#### accuracy analysis - switching ####
# COMMENTED OUT MODELS THAT DO NOT CONVERGE AND ARE NOT USED IN SUBSEQUENT ANALYSIS
#GLME: DV accuracy01, predictors age group, rule, and trial type (switching)
#glme_NounVerb_accuracySwitching_Exp2= glmer(accuracy01~ Switching_coded*Agegroup_coded*Rule_coded + (1+Switching_coded*Rule_coded|participant) + (1+Switching_coded*Agegroup_coded*Rule_coded|Item), data = NounVerb_Exp2_switching, family = binomial, control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
#does not converge, remove correlations
#glme_NounVerb_accuracySwitching_Exp2_1= glmer(accuracy01~ Switching_coded*Agegroup_coded*Rule_coded + (1+Switching_coded*Rule_coded||participant) + (1+Switching_coded*Agegroup_coded*Rule_coded||Item), data = NounVerb_Exp2_switching, family = binomial, control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
#does not converge, remove item slope for switching x age and switching x age x rule
#glme_NounVerb_accuracySwitching_Exp2_2= glmer(accuracy01~ Switching_coded*Agegroup_coded*Rule_coded + (1+Switching_coded*Rule_coded||participant) + (1+Switching_coded+Agegroup_coded+Rule_coded+Switching_coded:Rule_coded+Agegroup_coded:Rule_coded||Item), data = NounVerb_Exp2_switching, family = binomial, control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
#does not converge, remove item slope for switching x rule
glme_NounVerb_accuracySwitching_Exp2_3= glmer(accuracy01~ Switching_coded*Agegroup_coded*Rule_coded + (1+Switching_coded*Rule_coded||participant) + (1+Switching_coded+Rule_coded+Agegroup_coded+Agegroup_coded:Rule_coded||Item), data = NounVerb_Exp2_switching, family = binomial, control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
summary(glme_NounVerb_accuracySwitching_Exp2_3)

#### next analysis is on mixing effect ####
#take subset of single-task and non-switch trials for mixing analysis
NounVerb_Exp2_mixing <- subset(NounVerb_Exp2, NounVerb_Exp2$TrialType == "SingleNaming" | NounVerb_Exp2$TrialType == "nonswitch")
#contrast code MIXING
NounVerb_Exp2_mixing$Mixing_coded = as.factor(NounVerb_Exp2_mixing$TrialType)
NounVerb_Exp2_mixing$Mixing_coded <- ifelse(NounVerb_Exp2_mixing$Mixing_coded == "SingleNaming", -0.5, ifelse(NounVerb_Exp2_mixing$Mixing_coded== "nonswitch", 0.5, 99))
aggregate(Mixing_coded~TrialType, data=NounVerb_Exp2_mixing, mean, na.rm=TRUE)

#### accuracy analysis - mixing ####
# COMMENTED OUT MODELS THAT DO NOT CONVERGE AND ARE NOT USED IN SUBSEQUENT ANALYSIS
#GLME: DV accuracy01, predictors age group, rule, and trial type (mixing)
#glme_NounVerb_accuracyMixing_Exp2= glmer(accuracy01~ Mixing_coded*Agegroup_coded*Rule_coded + (1+Mixing_coded*Rule_coded|participant) + (1+Mixing_coded*Agegroup_coded*Rule_coded|Item), data = NounVerb_Exp2_mixing, family = binomial, control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
#does not converge, remove correlations
#glme_NounVerb_accuracyMixing_Exp2_1= glmer(accuracy01~ Mixing_coded*Agegroup_coded*Rule_coded + (1+Mixing_coded*Rule_coded||participant) + (1+Mixing_coded*Agegroup_coded*Rule_coded||Item), data = NounVerb_Exp2_mixing, family = binomial, control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
#does not converge, remove item slopes for mixing x age, mixing x rule, and age x rule
glme_NounVerb_accuracyMixing_Exp2_2= glmer(accuracy01~ Mixing_coded*Agegroup_coded*Rule_coded + (1+Mixing_coded*Rule_coded||participant) + (1+Mixing_coded+Agegroup_coded+Rule_coded+Mixing_coded:Agegroup_coded:Rule_coded||Item), data = NounVerb_Exp2_mixing, family = binomial, control = glmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
summary(glme_NounVerb_accuracyMixing_Exp2_2)


#### reaction time Exp 2 noun-verb #### 
#### outlier removal steps ####

#keep accurate responses only & remove trials preceded by break or wrong rule
NounVerb_Exp2_acc<- subset(NounVerb_Exp2, NounVerb_Exp2$accuracy=="1")

#check distribution raw RT
NounVerb_Exp2_acc$rt <- as.numeric(as.character(NounVerb_Exp2_acc$rt))
#hist(NounVerb_Exp2_acc$rt)

#log RT for outlier removal
NounVerb_Exp2_acc$rawrt <-NounVerb_Exp2_acc$rt
NounVerb_Exp2_acc$rt <- log(NounVerb_Exp2_acc$rt)
#check histogram log RT
#hist(NounVerb_Exp2_acc$rt)

#create new condition variable that combines participant, trial type, and rule info
NounVerb_Exp2_acc$condition<-paste0(as.character(NounVerb_Exp2_acc$participant), (NounVerb_Exp2_acc$TrialType), (NounVerb_Exp2_acc$Rule))


#remove outliers 2.5 SD below/above mean per participant and condition
NounVerb_Exp2_acc_outliers <- sdTrim(data = NounVerb_Exp2_acc, minRT = 0, sd = 2.5, 
                               perCondition = TRUE, perParticipant = FALSE, 
                               returnType = "raw", digits = 20)

#Check distribution of log RT after outlier removal
#hist(NounVerb_Exp2_acc_outliers$rt)

#Write the trimmed data to a .csv file
write.csv(NounVerb_Exp2_acc_outliers, "data/NounVerb_Exp2_acc_outliers.csv")

#Prepare file for RT analysis

#### take subset of switch and non-switch trials for switching analysis ####
NounVerb_Exp2_acc_outliers_switching <- subset(NounVerb_Exp2_acc_outliers, NounVerb_Exp2_acc_outliers$TrialType == "switch" | NounVerb_Exp2_acc_outliers$TrialType == "nonswitch")
#contrast code SWITCHING
NounVerb_Exp2_acc_outliers_switching$Switching_coded = as.factor(NounVerb_Exp2_acc_outliers_switching$TrialType)
NounVerb_Exp2_acc_outliers_switching$Switching_coded <- ifelse(NounVerb_Exp2_acc_outliers_switching$Switching_coded == "nonswitch", -0.5, ifelse(NounVerb_Exp2_acc_outliers_switching$Switching_coded== "switch", 0.5, 99))
aggregate(Switching_coded~TrialType, data=NounVerb_Exp2_acc_outliers_switching, mean, na.rm=TRUE)

#### switching analysis Exp noun-verb ####
# COMMENTED OUT MODELS THAT DO NOT CONVERGE AND ARE NOT USED IN SUBSEQUENT ANALYSIS
#LME: log RT DV, predictors age group, rule, and trial type (switching)
#lme_NounVerb_Exp2= lmer(rt~ Switching_coded*Agegroup_coded*Rule_coded + (1+Switching_coded*Rule_coded|participant) + (1+Switching_coded*Agegroup_coded*Rule_coded|Item), REML = TRUE, data = NounVerb_Exp2_acc_outliers_switching,control = lmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
#does not converge, remove correlations
#lme_NounVerb_Exp2_1= lmer(rt~ Switching_coded*Agegroup_coded*Rule_coded + (1+Switching_coded*Rule_coded||participant) + (1+Switching_coded*Agegroup_coded*Rule_coded||Item), REML = TRUE, data = NounVerb_Exp2_acc_outliers_switching,control = lmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
#does not converge, remove item slope for switching x age x rule
lme_NounVerb_Exp2_2= lmer(rt~ Switching_coded*Agegroup_coded*Rule_coded + (1+Switching_coded*Rule_coded||participant) + (1+Switching_coded+Agegroup_coded+Rule_coded+Switching_coded:Agegroup_coded+Switching_coded:Rule_coded+Agegroup_coded:Rule_coded||Item), REML = TRUE, data = NounVerb_Exp2_acc_outliers_switching,control = lmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
summary(lme_NounVerb_Exp2_2)

#### next analysis is on mixing effect ####
#take subset of single-task and non-switch trials for mixing analysis
NounVerb_Exp2_acc_outliers_mixing <- subset(NounVerb_Exp2_acc_outliers, NounVerb_Exp2_acc_outliers$TrialType == "SingleNaming" | NounVerb_Exp2_acc_outliers$TrialType == "nonswitch")
#contrast code MIXING
NounVerb_Exp2_acc_outliers_mixing$Mixing_coded = as.factor(NounVerb_Exp2_acc_outliers_mixing$TrialType)
NounVerb_Exp2_acc_outliers_mixing$Mixing_coded <- ifelse(NounVerb_Exp2_acc_outliers_mixing$Mixing_coded == "SingleNaming", -0.5, ifelse(NounVerb_Exp2_acc_outliers_mixing$Mixing_coded== "nonswitch", 0.5, 99))
aggregate(Mixing_coded~TrialType, data=NounVerb_Exp2_acc_outliers_mixing, mean, na.rm=TRUE)

#### mixing analysis Exp noun-verb ####
# COMMENTED OUT MODELS THAT DO NOT CONVERGE AND ARE NOT USED IN SUBSEQUENT ANALYSIS
#LME: log RT DV, predictors age group, rule, and trial type (mixing)
#NounVerb_Exp2_mixing= lmer(rt~ Mixing_coded*Agegroup_coded*Rule_coded + (1+Mixing_coded*Rule_coded|participant) + (1+Mixing_coded*Agegroup_coded*Rule_coded|Item), REML = TRUE, data = NounVerb_Exp2_acc_outliers_mixing,control = lmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
#does not converge, remove correlations
NounVerb_Exp2_mixing_2= lmer(rt~ Mixing_coded*Agegroup_coded*Rule_coded + (1+Mixing_coded*Rule_coded||participant) + (1+Mixing_coded*Agegroup_coded*Rule_coded||Item), REML = TRUE, data = NounVerb_Exp2_acc_outliers_mixing,control = lmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
summary(NounVerb_Exp2_mixing_2)


#################################
# SEMANTIC TASK                 #
################################
#open file for semantic control task
Semantic_Exp2 <- read.csv("data/SemanticControl.csv")

#keep accurate responses only
Semantic_Exp2_acc<- subset(Semantic_Exp2, Semantic_Exp2$accuracy=="1")

#remove participant 54 (only 1 correct incon trial)
Semantic_Exp2_acc <- subset(Semantic_Exp2_acc, Semantic_Exp2_acc$participant!="54")


#check distribution raw RT
Semantic_Exp2_acc$rt <- as.numeric(as.character(Semantic_Exp2_acc$rt))
#hist(Semantic_Exp2_acc$rt)

#log RT for outlier removal
Semantic_Exp2_acc$rawrt <-Semantic_Exp2_acc$rt
Semantic_Exp2_acc$rt <- log(Semantic_Exp2_acc$rt)
#check histogram log RT
#hist(Semantic_Exp2_acc$rt)

#create new condition variable that combines participant, trial type, and language info
Semantic_Exp2_acc$condition<-paste0(as.character(Semantic_Exp2_acc$participant), (Semantic_Exp2_acc$control))

#remove outliers 2.5 SD below/above mean per participant and condition

Semantic_Exp2_acc_outliers <- sdTrim(data = Semantic_Exp2_acc, minRT = 0, sd = 2.5, 
                                      perCondition = TRUE, perParticipant = FALSE, 
                                      returnType = "raw", digits = 20)

#Check distribution of log RT after outlier removal
#hist(Semantic_Exp2_acc_outliers$rt)

#Write the trimmed data to a .csv file
write.csv(Semantic_Exp2_acc_outliers, "data/Semantic_Exp2_acc_outliers.csv")

#Prepare file for RT analysis
#contrast code AGE GROUP
Semantic_Exp2_acc_outliers$Agegroup_coded = as.factor(Semantic_Exp2_acc_outliers$AgeGroup)
Semantic_Exp2_acc_outliers$Agegroup_coded <- ifelse(Semantic_Exp2_acc_outliers$Agegroup_coded == "Younger", -0.5, ifelse(Semantic_Exp2_acc_outliers$Agegroup_coded== "Older", 0.5, 99))
aggregate(Agegroup_coded~AgeGroup, data=Semantic_Exp2_acc_outliers, mean, na.rm=TRUE)

#contrast code high/low control
Semantic_Exp2_acc_outliers$Control_coded = as.factor(Semantic_Exp2_acc_outliers$control)
Semantic_Exp2_acc_outliers$Control_coded <- ifelse(Semantic_Exp2_acc_outliers$Control_coded == "cong", -0.5, ifelse(Semantic_Exp2_acc_outliers$Control_coded== "incon", 0.5, 99))
aggregate(Control_coded~control, data=Semantic_Exp2_acc_outliers, mean, na.rm=TRUE)

#LME: log RT DV, predictors age group, control
lme_semantic_Exp2= lmer(rt~ Control_coded*Agegroup_coded + (1+Control_coded|participant) + (1+Agegroup_coded|item), REML = TRUE, data = Semantic_Exp2_acc_outliers,control = lmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
summary(lme_semantic_Exp2)



#### task comparisons ####
#final analyses, comparing age effects across tasks
#open file for task comparison
TaskComparison_Exp2 <- read.csv("data/TaskComparison.csv")

#contrast code AGE GROUP
TaskComparison_Exp2$Agegroup_coded = as.factor(TaskComparison_Exp2$AgeGroup)
TaskComparison_Exp2$Agegroup_coded <- ifelse(TaskComparison_Exp2$Agegroup_coded == "Younger", -0.5, ifelse(TaskComparison_Exp2$Agegroup_coded== "Older", 0.5, 99))
aggregate(Agegroup_coded~AgeGroup, data=TaskComparison_Exp2, mean, na.rm=TRUE)

#first comparison is between the bilingual switching cost, noun-verb switching cost, and semantic control task
#only keep trials coded as high or low difficulty (this excludes single-naming trials):
TaskComparison_Exp2_control <- subset(TaskComparison_Exp2, TaskComparison_Exp2$Difficulty == "low" | TaskComparison_Exp2$Difficulty == "high")

#contrast code Difficulty (this is high or low, high: incongruent semantic, switch bilingual, switch noun-verb; low refers to congruent semantic, non-switch bilingual, and non-switch noun-verb)
TaskComparison_Exp2_control$Difficulty_coded <- as.factor(TaskComparison_Exp2_control$Difficulty)
TaskComparison_Exp2_control$Difficulty_coded <- ifelse(TaskComparison_Exp2_control$Difficulty_coded == "low", -0.5, ifelse(TaskComparison_Exp2_control$Difficulty_coded== "high", 0.5, 99))
aggregate(Difficulty_coded~Difficulty, data=TaskComparison_Exp2_control, mean, na.rm=TRUE)

#code task: using helmert coding to compare the two switching tasks to each other and the switching tasks to the semantic control measure.
TaskComparison_Exp2_control$Task_coded <- factor(TaskComparison_Exp2_control$Task, levels=c("Bilingual","NounVerb","Semantic"))
levels(TaskComparison_Exp2_control$Task_coded)
contrasts(TaskComparison_Exp2_control$Task_coded) = cbind(c(-0.5, 0.5, 0), c(-1/3, -1/3, 2/3))
contrasts(TaskComparison_Exp2_control$Task_coded)

#remove participant 54 as they don't have a semantic control cost
TaskComparison_Exp2_control_no54<- subset(TaskComparison_Exp2_control, TaskComparison_Exp2_control$participant!="54")

# COMMENTED OUT MODELS THAT DO NOT CONVERGE AND ARE NOT USED IN SUBSEQUENT ANALYSIS
#LME: log RT DV, predictors age group, task, and trial type (high/low control). No item slope for difficulty or task as items differed between tasks and semantic items differed between difficulty level
#lme_TaskComp_Exp2_control= lmer(rt~ Difficulty_coded*Agegroup_coded*Task_coded + (1+Difficulty_coded*Task_coded|participant) + (1+Agegroup_coded|item), REML = TRUE, data = TaskComparison_Exp2_control_no54,control = lmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
#does not converge, remove correlations
#lme_TaskComp_Exp2_control_1= lmer(rt~ Difficulty_coded*Agegroup_coded*Task_coded + (1+Difficulty_coded*Task_coded||participant) + (1+Agegroup_coded||item), REML = TRUE, data = TaskComparison_Exp2_control_no54,control = lmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
#does not converge, remove item slope for age group
#lme_TaskComp_Exp2_control_2= lmer(rt~ Difficulty_coded*Agegroup_coded*Task_coded + (1+Difficulty_coded*Task_coded||participant) + (1|item), REML = TRUE, data = TaskComparison_Exp2_control_no54,control = lmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
#does not converge, remove participant slope for difficulty x task
lme_TaskComp_Exp2_control_3= lmer(rt~ Difficulty_coded*Agegroup_coded*Task_coded + (1+Difficulty_coded+Task_coded||participant) + (1|item), REML = TRUE, data = TaskComparison_Exp2_control_no54,control = lmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
summary(lme_TaskComp_Exp2_control_3)


#Second comparison is on the mixing effects in the noun-verb versus bilingual task
#take subset of single-task and non-switch trials for mixing analysis
TaskComparison_Exp2_mixing <- subset(TaskComparison_Exp2, TaskComparison_Exp2$TrialType == "SingleNaming" | TaskComparison_Exp2$TrialType == "nonswitch")
#contrast code MIXING
TaskComparison_Exp2_mixing$Mixing_coded <- as.factor(TaskComparison_Exp2_mixing$TrialType)
TaskComparison_Exp2_mixing$Mixing_coded <- ifelse(TaskComparison_Exp2_mixing$Mixing_coded == "SingleNaming", -0.5, ifelse(TaskComparison_Exp2_mixing$Mixing_coded== "nonswitch", 0.5, 99))
aggregate(Mixing_coded~TrialType, data=TaskComparison_Exp2_mixing, mean, na.rm=TRUE)

#contrast code TASK
TaskComparison_Exp2_mixing$Task_coded = as.factor(TaskComparison_Exp2_mixing$Task)
TaskComparison_Exp2_mixing$Task_coded <- ifelse(TaskComparison_Exp2_mixing$Task_coded == "NounVerb", -0.5, ifelse(TaskComparison_Exp2_mixing$Task_coded== "Bilingual", 0.5, 99))
aggregate(Task_coded~Task, data=TaskComparison_Exp2_mixing, mean, na.rm=TRUE)

# COMMENTED OUT MODELS THAT DO NOT CONVERGE AND ARE NOT USED IN SUBSEQUENT ANALYSIS
#LME: log RT DV, predictors age group, task, and trial type (mixing) - note that pre-registration did not include difficulty level
#lme_TaskComp_Exp2_mixing= lmer(rt~ Mixing_coded*Agegroup_coded*Task_coded + (1+Mixing_coded*Task_coded|participant) + (1+Mixing_coded*Agegroup_coded*Task_coded|item), REML = TRUE, data = TaskComparison_Exp2_mixing,control = lmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
#does not converge, remove correlations
#lme_TaskComp_Exp2_mixing_1= lmer(rt~ Mixing_coded*Agegroup_coded*Task_coded + (1+Mixing_coded*Task_coded||participant) + (1+Mixing_coded*Agegroup_coded*Task_coded||item), REML = TRUE, data = TaskComparison_Exp2_mixing,control = lmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
#does not converge, remove item slope for mixing x age
lme_TaskComp_Exp2_mixing_2= lmer(rt~ Mixing_coded*Agegroup_coded*Task_coded + (1+Mixing_coded*Task_coded||participant) + (1+Mixing_coded+Agegroup_coded+Task_coded+Mixing_coded:Task_coded+Agegroup_coded:Task_coded+Mixing_coded:Agegroup_coded:Task_coded||item), REML = TRUE, data = TaskComparison_Exp2_mixing,control = lmerControl(optimizer = "bobyqa",optCtrl=list(maxfun=1000000)))
taskcompout <- summary(lme_TaskComp_Exp2_mixing_2)


# save analyses (updated to include exp2)
varlist <- c('LS_Exp1','LS_Exp1_switching','glme_LS_accSwitching_Exp1_7','LS_Exp1_mixing','glme_LS_accMixing_Exp1_4','LS_Exp1_acc','LS_Exp1_acc_outliers','LS_Exp1_acc_outliers_switching','lme_LS_Exp1_2','LS_Exp1_acc_outliers_mixing','lme_LS_Exp1_mixing_1','NLS_Exp1','NLS_Exp1_switching','glme_NLS_accSwitching_Exp1_10','NLS_Exp1_mixing','glme_NLS_accMixing_Exp1_2','NLS_Exp1_acc','NLS_Exp1_acc_outliers_switching','NLS_Exp1_acc_outliers','lme_NLS_Exp1_2','NLS_Exp1_acc_outliers_switching_minus3','lme_NLS_Exp1_2_minus3','NLS_Exp1_acc_outliers_mixing','lme_NLS_Exp1_mixing_2','NLS_Exp1_acc_outliers_mixing_minus3','lme_NLS_Exp1_mixing_3_minus3','lme_NLS_Exp1_mixing_2_zscore_conv','Bilingual_Exp2','Bilingual_Exp2_switching','glme_Bilingual_accSwitching_Exp2_7', 'Bilingual_Exp2_mixing','glme_Bilingual_accMixing_Exp2_3','Bilingual_Exp2_acc','Bilingual_Exp2_acc_outliers','Bilingual_Exp2_acc_outliers_switching','lme_Bilingual_Exp2_1','Bilingual_Exp2_acc_outliers_mixing','lme_Bilingual_Exp2_mixing_1','lme_Bilingual_Exp2_mixing_zscore_1','lme_Bilingual_Exp2_switching_1_zscore','NounVerb_Exp2','NounVerb_Exp2_switching','glme_NounVerb_accuracySwitching_Exp2_3','NounVerb_Exp2_mixing','glme_NounVerb_accuracyMixing_Exp2_2','NounVerb_Exp2_acc','NounVerb_Exp2_acc_outliers','NounVerb_Exp2_acc_outliers_switching','lme_NounVerb_Exp2_2','NounVerb_Exp2_acc_outliers_mixing','NounVerb_Exp2_mixing_2','Semantic_Exp2','Semantic_Exp2_acc','Semantic_Exp2_acc_outliers','lme_semantic_Exp2','TaskComparison_Exp2','TaskComparison_Exp2_control','TaskComparison_Exp2_control_no54','lme_TaskComp_Exp2_control_3','TaskComparison_Exp2_mixing','lme_TaskComp_Exp2_mixing_2')
save(file = 'data/Exp1Exp2analysis.RData',list=varlist)

}

if (doanalysis==0){
  # load analyses
  load('data/Exp1Exp2analysis.RData')
}

```

``` {r extractexpt1results, include=FALSE}

#### correlational analyses Exp1 #####
##get noun-verb switching & mixing cost
means_LS_Exp1_Costs <- LS_Exp1_acc_outliers %>% 
  group_by(participant, TrialType) %>% 
  summarise(meanRT_all = mean(rawrt))

#get mixing & switching costs
means_LS_Exp1_Costs_pivot <- means_LS_Exp1_Costs %>% 
  pivot_wider(id_cols = participant, names_from = c(TrialType), values_from = meanRT_all)

head(means_LS_Exp1_Costs_pivot)
#switching cost per participant
means_LS_Exp1_Costs_pivot <- means_LS_Exp1_Costs_pivot %>% 
  mutate(SwitchingCost = switch - nonswitch)
#mixing cost per participant
means_LS_Exp1_Costs_pivot <- means_LS_Exp1_Costs_pivot %>% 
  mutate(MixingCost = nonswitch - SingleNaming)

##get non-linguistic switching & mixing cost
means_NLS_Exp1_Costs <- NLS_Exp1_acc_outliers %>% 
  group_by(participant, TrialType) %>% 
  summarise(meanRT_all = mean(rawrt))

#get mixing & switching costs
means_NLS_Exp1_Costs_pivot <- means_NLS_Exp1_Costs %>% 
  pivot_wider(id_cols = participant, names_from = c(TrialType), values_from = meanRT_all)

head(means_NLS_Exp1_Costs_pivot)
#switching cost per participant
means_NLS_Exp1_Costs_pivot <- means_NLS_Exp1_Costs_pivot %>% 
  mutate(SwitchingCost = switch - nonswitch)
#mixing cost per participant
means_NLS_Exp1_Costs_pivot <- means_NLS_Exp1_Costs_pivot %>% 
  mutate(MixingCost = nonswitch - SingleNaming)

#### get means for results section #### 
#### means for noun-verb task ####
#get participant mean per trial type
means_LS <- LS_Exp1_acc_outliers %>% 
  group_by(participant, TrialType) %>% 
  summarise(meanRT = mean(rawrt))

head(means_LS)
#get means & SD across participants per trial type
switchcostRT <- aggregate(meanRT~TrialType, data=means_LS, mean, na.rm=TRUE)
switchcostSD <- aggregate(meanRT~TrialType, data=means_LS, sd, na.rm=TRUE)

#get participant mean per age group for switching analysis
means_LS_age <- LS_Exp1_acc_outliers_switching %>% 
  group_by(participant, AgeGroup) %>% 
  summarise(meanRT = mean(rawrt))
head(means_LS_age)
ageRT <- aggregate(meanRT~AgeGroup, data=means_LS_age, mean, na.rm=TRUE)
ageSD <- aggregate(meanRT~AgeGroup, data=means_LS_age, sd, na.rm=TRUE)

#get participant mean per age group for mixing analysis
means_LS_age_mix <- LS_Exp1_acc_outliers_mixing %>% 
  group_by(participant, AgeGroup) %>% 
  summarise(meanRT = mean(rawrt))
head(means_LS_age_mix)
ageRTmix <- aggregate(meanRT~AgeGroup, data=means_LS_age_mix, mean, na.rm=TRUE)
ageSDmix <- aggregate(meanRT~AgeGroup, data=means_LS_age_mix, sd, na.rm=TRUE)

#get participant mean per rule for mixing analysis
means_LS_rule_mix <- LS_Exp1_acc_outliers_mixing %>% 
  group_by(participant, Rule) %>% 
  summarise(meanRT = mean(rawrt))
head(means_LS_rule_mix)
aggregate(meanRT~Rule, data=means_LS_rule_mix, mean, na.rm=TRUE)
aggregate(meanRT~Rule, data=means_LS_rule_mix, sd, na.rm=TRUE)


####get means for Table per combination of conditions (TABLE 1)
#get participant mean per trial type
means_LS_allcombs <- LS_Exp1_acc_outliers %>% 
  group_by(participant, TrialType, Rule, AgeGroup) %>% 
  summarise(meanRT_all = mean(rawrt))

head(means_LS_allcombs)
#get means across participants
table1means <- aggregate(meanRT_all~AgeGroup+Rule+TrialType, data=means_LS_allcombs, mean, na.rm=TRUE)
table1sds <- aggregate(meanRT_all~AgeGroup+Rule+TrialType, data=means_LS_allcombs, sd, na.rm=TRUE)

#get mixing & switching costs
means_LS_allcombs_pivot <- means_LS_allcombs %>% 
  pivot_wider(id_cols = participant, names_from = c(TrialType,Rule,AgeGroup), values_from = meanRT_all)

t1outM <- NULL
t1outSD <- NULL

head(means_LS_allcombs_pivot)
#switching cost per combi
means_LS_allcombs_pivot <- means_LS_allcombs_pivot %>% 
  mutate(SwitchingCostYoungerAction = switch_ACTION_Younger - nonswitch_ACTION_Younger,
         SwitchingCostOlderAction = switch_ACTION_Older - nonswitch_ACTION_Older,
         SwitchingCostYoungerObject = switch_OBJECT_Younger - nonswitch_OBJECT_Younger,
         SwitchingCostOlderObject = switch_OBJECT_Older - nonswitch_OBJECT_Older)
#get means across participants
t1outM[8] <- mean(means_LS_allcombs_pivot$SwitchingCostOlderAction, na.rm=TRUE)
t1outSD[8] <- sd(means_LS_allcombs_pivot$SwitchingCostOlderAction, na.rm=TRUE)
t1outM[7] <- mean(means_LS_allcombs_pivot$SwitchingCostOlderObject, na.rm=TRUE)
t1outSD[7] <- sd(means_LS_allcombs_pivot$SwitchingCostOlderObject, na.rm=TRUE)
t1outM[4] <- mean(means_LS_allcombs_pivot$SwitchingCostYoungerAction, na.rm=TRUE)
t1outSD[4] <- sd(means_LS_allcombs_pivot$SwitchingCostYoungerAction, na.rm=TRUE)
t1outM[3] <- mean(means_LS_allcombs_pivot$SwitchingCostYoungerObject, na.rm=TRUE)
t1outSD[3] <- sd(means_LS_allcombs_pivot$SwitchingCostYoungerObject, na.rm=TRUE)

#mixing costs per combi
means_LS_allcombs_pivot <- means_LS_allcombs_pivot %>% 
  mutate(MixingCostYoungerAction = nonswitch_ACTION_Younger - SingleNaming_ACTION_Younger,
         MixingCostOlderAction = nonswitch_ACTION_Older - SingleNaming_ACTION_Older,
         MixingCostYoungerObject = nonswitch_OBJECT_Younger - SingleNaming_OBJECT_Younger,
         MixingCostOlderObject = nonswitch_OBJECT_Older - SingleNaming_OBJECT_Older)
#get means across participants
t1outM[6] <- mean(means_LS_allcombs_pivot$MixingCostOlderAction, na.rm=TRUE)
t1outSD[6] <- sd(means_LS_allcombs_pivot$MixingCostOlderAction, na.rm=TRUE)
t1outM[5] <- mean(means_LS_allcombs_pivot$MixingCostOlderObject, na.rm=TRUE)
t1outSD[5] <- sd(means_LS_allcombs_pivot$MixingCostOlderObject, na.rm=TRUE)
t1outM[2] <- mean(means_LS_allcombs_pivot$MixingCostYoungerAction, na.rm=TRUE)
t1outSD[2] <- sd(means_LS_allcombs_pivot$MixingCostYoungerAction, na.rm=TRUE)
t1outM[1] <- mean(means_LS_allcombs_pivot$MixingCostYoungerObject, na.rm=TRUE)
t1outSD[1] <- sd(means_LS_allcombs_pivot$MixingCostYoungerObject, na.rm=TRUE)

#mixing cost per rule, across age groups
means_LS_rulegeneral_mix <- LS_Exp1_acc_outliers_mixing %>% 
  group_by(participant, Rule, TrialType) %>% 
  summarise(meanRT = mean(rawrt))
head(means_LS_rulegeneral_mix)

means_LS_mixingrulegeneral_pivot <- means_LS_rulegeneral_mix %>% 
  pivot_wider(id_cols = participant, names_from = c(Rule, TrialType), values_from = meanRT)

head(means_LS_mixingrulegeneral_pivot)

means_LS_mixingrulegeneral_pivot <- means_LS_mixingrulegeneral_pivot %>% 
  mutate(MixingCostAction = ACTION_nonswitch - ACTION_SingleNaming,
         MixingCostObject = OBJECT_nonswitch - OBJECT_SingleNaming)
mmix1 <- mean(means_LS_mixingrulegeneral_pivot$MixingCostAction, na.rm=TRUE)
sdmix1 <- sd(means_LS_mixingrulegeneral_pivot$MixingCostAction, na.rm=TRUE)
mmix2 <- mean(means_LS_mixingrulegeneral_pivot$MixingCostObject, na.rm=TRUE)
sdmix2 <- sd(means_LS_mixingrulegeneral_pivot$MixingCostObject, na.rm=TRUE)

#### means for non-linguistic task ####
####get means for Table per combination of conditions
#get participant mean per trial type
means_NLS_allcombs <- NLS_Exp1_acc_outliers %>% 
  group_by(participant, TrialType, Rule, AgeGroup) %>% 
  summarise(meanRT_all = mean(rawrt))

head(means_NLS_allcombs)
#get means across participants
aggregate(meanRT_all~AgeGroup+Rule+TrialType, data=means_NLS_allcombs, mean, na.rm=TRUE)
aggregate(meanRT_all~AgeGroup+Rule+TrialType, data=means_NLS_allcombs, sd, na.rm=TRUE)

#get mixing & switching costs
means_NLS_allcombs_pivot <- means_NLS_allcombs %>% 
  pivot_wider(id_cols = participant, names_from = c(TrialType,Rule,AgeGroup), values_from = meanRT_all)

table3means <- matrix(0,nrow=15,ncol=2)
table3SDs <- matrix(0,nrow=15,ncol=2)

table3means[2,2] <- mean(means_NLS_allcombs_pivot$SingleNaming_PARITY_Older, na.rm=TRUE)
table3SDs[2,2] <- sd(means_NLS_allcombs_pivot$SingleNaming_PARITY_Older, na.rm=TRUE)
table3means[1,2] <- mean(means_NLS_allcombs_pivot$SingleNaming_SIZE_Older, na.rm=TRUE)
table3SDs[1,2] <- sd(means_NLS_allcombs_pivot$SingleNaming_SIZE_Older, na.rm=TRUE)
table3means[2,1] <- mean(means_NLS_allcombs_pivot$SingleNaming_PARITY_Younger, na.rm=TRUE)
table3SDs[2,1] <- sd(means_NLS_allcombs_pivot$SingleNaming_PARITY_Younger, na.rm=TRUE)
table3means[1,1] <- mean(means_NLS_allcombs_pivot$SingleNaming_SIZE_Younger, na.rm=TRUE)
table3SDs[1,1] <- sd(means_NLS_allcombs_pivot$SingleNaming_SIZE_Younger, na.rm=TRUE)

table3means[4,2] <- mean(means_NLS_allcombs_pivot$nonswitch_PARITY_Older, na.rm=TRUE)
table3SDs[4,2] <- sd(means_NLS_allcombs_pivot$nonswitch_PARITY_Older, na.rm=TRUE)
table3means[3,2] <- mean(means_NLS_allcombs_pivot$nonswitch_SIZE_Older, na.rm=TRUE)
table3SDs[3,2] <- sd(means_NLS_allcombs_pivot$nonswitch_SIZE_Older, na.rm=TRUE)
table3means[4,1] <- mean(means_NLS_allcombs_pivot$nonswitch_PARITY_Younger, na.rm=TRUE)
table3SDs[4,1] <- sd(means_NLS_allcombs_pivot$nonswitch_PARITY_Younger, na.rm=TRUE)
table3means[3,1] <- mean(means_NLS_allcombs_pivot$nonswitch_SIZE_Younger, na.rm=TRUE)
table3SDs[3,1] <- sd(means_NLS_allcombs_pivot$nonswitch_SIZE_Younger, na.rm=TRUE)

table3means[6,2] <- mean(means_NLS_allcombs_pivot$switch_PARITY_Older, na.rm=TRUE)
table3SDs[6,2] <- sd(means_NLS_allcombs_pivot$switch_PARITY_Older, na.rm=TRUE)
table3means[5,2] <- mean(means_NLS_allcombs_pivot$switch_SIZE_Older, na.rm=TRUE)
table3SDs[5,2] <- sd(means_NLS_allcombs_pivot$switch_SIZE_Older, na.rm=TRUE)
table3means[6,1] <- mean(means_NLS_allcombs_pivot$switch_PARITY_Younger, na.rm=TRUE)
table3SDs[6,1] <- sd(means_NLS_allcombs_pivot$switch_PARITY_Younger, na.rm=TRUE)
table3means[5,1] <- mean(means_NLS_allcombs_pivot$switch_SIZE_Younger, na.rm=TRUE)
table3SDs[5,1] <- sd(means_NLS_allcombs_pivot$switch_SIZE_Younger, na.rm=TRUE)

head(means_NLS_allcombs_pivot)
#switching cost per combi
means_NLS_allcombs_pivot <- means_NLS_allcombs_pivot %>% 
  mutate(SwitchingCostYoungerPARITY = switch_PARITY_Younger - nonswitch_PARITY_Younger,
         SwitchingCostOlderPARITY = switch_PARITY_Older - nonswitch_PARITY_Older,
         SwitchingCostYoungerSIZE = switch_SIZE_Younger - nonswitch_SIZE_Younger,
         SwitchingCostOlderSIZE = switch_SIZE_Older - nonswitch_SIZE_Older)
#get means across participants
table3means[10,2] <- mean(means_NLS_allcombs_pivot$SwitchingCostOlderPARITY, na.rm=TRUE)
table3SDs[10,2] <- sd(means_NLS_allcombs_pivot$SwitchingCostOlderPARITY, na.rm=TRUE)
table3means[9,2] <- mean(means_NLS_allcombs_pivot$SwitchingCostOlderSIZE, na.rm=TRUE)
table3SDs[9,2] <- sd(means_NLS_allcombs_pivot$SwitchingCostOlderSIZE, na.rm=TRUE)
table3means[10,1] <- mean(means_NLS_allcombs_pivot$SwitchingCostYoungerPARITY, na.rm=TRUE)
table3SDs[10,1] <- sd(means_NLS_allcombs_pivot$SwitchingCostYoungerPARITY, na.rm=TRUE)
table3means[9,1] <- mean(means_NLS_allcombs_pivot$SwitchingCostYoungerSIZE, na.rm=TRUE)
table3SDs[9,1] <- sd(means_NLS_allcombs_pivot$SwitchingCostYoungerSIZE, na.rm=TRUE)

#mixing costs per combi
means_NLS_allcombs_pivot <- means_NLS_allcombs_pivot %>% 
  mutate(MixingCostYoungerPARITY = nonswitch_PARITY_Younger - SingleNaming_PARITY_Younger,
         MixingCostOlderPARITY = nonswitch_PARITY_Older - SingleNaming_PARITY_Older,
         MixingCostYoungerSIZE = nonswitch_SIZE_Younger - SingleNaming_SIZE_Younger,
         MixingCostOlderSIZE = nonswitch_SIZE_Older - SingleNaming_SIZE_Older)
#get means across participants
table3means[8,2] <- mean(means_NLS_allcombs_pivot$MixingCostOlderPARITY, na.rm=TRUE)
table3SDs[8,2] <- sd(means_NLS_allcombs_pivot$MixingCostOlderPARITY, na.rm=TRUE)
table3means[7,2] <- mean(means_NLS_allcombs_pivot$MixingCostOlderSIZE, na.rm=TRUE)
table3SDs[7,2] <- sd(means_NLS_allcombs_pivot$MixingCostOlderSIZE, na.rm=TRUE)
table3means[8,1] <- mean(means_NLS_allcombs_pivot$MixingCostYoungerPARITY, na.rm=TRUE)
table3SDs[8,1] <- sd(means_NLS_allcombs_pivot$MixingCostYoungerPARITY, na.rm=TRUE)
table3means[7,1] <- mean(means_NLS_allcombs_pivot$MixingCostYoungerSIZE, na.rm=TRUE)
table3SDs[7,1] <- sd(means_NLS_allcombs_pivot$MixingCostYoungerSIZE, na.rm=TRUE)

#get participant mean per trial type
means_NLS <- NLS_Exp1_acc_outliers %>% 
  group_by(participant, TrialType) %>% 
  summarise(meanRT = mean(rawrt))

head(means_NLS)
#get means & SD across participants per trial type
NLSswitchM <- aggregate(meanRT~TrialType, data=means_NLS, mean, na.rm=TRUE)
NLSswitchSD <- aggregate(meanRT~TrialType, data=means_NLS, sd, na.rm=TRUE)

#get participant mean per age group, across mixing and switching
means_NLS_age <- NLS_Exp1_acc_outliers %>% 
  group_by(participant, AgeGroup) %>% 
  summarise(meanRT = mean(rawrt))
head(means_NLS_age)
NLSswitchM2 <- aggregate(meanRT~AgeGroup, data=means_NLS_age, mean, na.rm=TRUE)
NLSswitchSD2 <- aggregate(meanRT~AgeGroup, data=means_NLS_age, sd, na.rm=TRUE)

#mixing cost per age group, using log RTs
means_NLS_log_mix <- NLS_Exp1_acc_outliers_mixing %>% 
  group_by(participant, TrialType, AgeGroup) %>% 
  summarise(meanRT = mean(rt))
head(means_NLS_log_mix)

means_NLS_mixinglog_pivot <- means_NLS_log_mix %>% 
  pivot_wider(id_cols = participant, names_from = c(TrialType, AgeGroup), values_from = meanRT)

head(means_NLS_mixinglog_pivot)

logRT <- NULL
logSD <- NULL

means_NLS_mixinglog_pivot <- means_NLS_mixinglog_pivot %>% 
  mutate(MixingCostOlder =  nonswitch_Older- SingleNaming_Older,
         MixingCostYounger = nonswitch_Younger- SingleNaming_Younger)
logRT[1] <- mean(means_NLS_mixinglog_pivot$MixingCostOlder, na.rm=TRUE)
logSD[1] <- sd(means_NLS_mixinglog_pivot$MixingCostOlder, na.rm=TRUE)
logRT[2] <- mean(means_NLS_mixinglog_pivot$MixingCostYounger, na.rm=TRUE)
logSD[2] <- sd(means_NLS_mixinglog_pivot$MixingCostYounger, na.rm=TRUE)

###accuracy means for Supplementary Table 1
####get means for Table per combination of conditions
#get participant mean per trial type & rule
means_LS_acc_allcombs <- LS_Exp1 %>% 
  group_by(participant, TrialType, Rule, AgeGroup) %>% 
  summarise(meanacc_all = mean(accuracy01))

head(means_LS_acc_allcombs)
#get means across participants
tableS1means <- aggregate(meanacc_all~AgeGroup+Rule+TrialType, data=means_LS_acc_allcombs, mean, na.rm=TRUE)
tableS1SDs <- aggregate(meanacc_all~AgeGroup+Rule+TrialType, data=means_LS_acc_allcombs, sd, na.rm=TRUE)

tableS1mixswitch <- matrix(0,nrow=4,ncol=2)
tableS1mixswitchSD <- matrix(0,nrow=4,ncol=2)

#get mixing & switching costs
means_LS_acc_allcombs_pivot <- means_LS_acc_allcombs %>% 
  pivot_wider(id_cols = participant, names_from = c(TrialType,Rule,AgeGroup), values_from = meanacc_all)

head(means_LS_acc_allcombs_pivot)
#switching cost per combi
means_LS_acc_allcombs_pivot <- means_LS_acc_allcombs_pivot %>% 
  mutate(SwitchingCostYoungerAction = switch_ACTION_Younger - nonswitch_ACTION_Younger,
         SwitchingCostOlderAction = switch_ACTION_Older - nonswitch_ACTION_Older,
         SwitchingCostYoungerObject = switch_OBJECT_Younger - nonswitch_OBJECT_Younger,
         SwitchingCostOlderObject = switch_OBJECT_Older - nonswitch_OBJECT_Older)
#get means across participants
tableS1mixswitch[4,2] <- 100*mean(means_LS_acc_allcombs_pivot$SwitchingCostOlderAction, na.rm=TRUE)
tableS1mixswitchSD[4,2] <- 100*sd(means_LS_acc_allcombs_pivot$SwitchingCostOlderAction, na.rm=TRUE)
tableS1mixswitch[3,2] <- 100*mean(means_LS_acc_allcombs_pivot$SwitchingCostOlderObject, na.rm=TRUE)
tableS1mixswitchSD[3,2] <- 100*sd(means_LS_acc_allcombs_pivot$SwitchingCostOlderObject, na.rm=TRUE)
tableS1mixswitch[4,1] <- 100*mean(means_LS_acc_allcombs_pivot$SwitchingCostYoungerAction, na.rm=TRUE)
tableS1mixswitchSD[4,1] <- 100*sd(means_LS_acc_allcombs_pivot$SwitchingCostYoungerAction, na.rm=TRUE)
tableS1mixswitch[3,1] <- 100*mean(means_LS_acc_allcombs_pivot$SwitchingCostYoungerObject, na.rm=TRUE)
tableS1mixswitchSD[3,1] <- 100*sd(means_LS_acc_allcombs_pivot$SwitchingCostYoungerObject, na.rm=TRUE) 

#mixing cost per combi
means_LS_acc_allcombs_pivot <- means_LS_acc_allcombs_pivot %>% 
  mutate(MixingCostYoungerAction = nonswitch_ACTION_Younger - SingleNaming_ACTION_Younger,
         MixingCostOlderAction = nonswitch_ACTION_Older - SingleNaming_ACTION_Older,
         MixingCostYoungerObject = nonswitch_OBJECT_Younger - SingleNaming_OBJECT_Younger,
         MixingCostOlderObject = nonswitch_OBJECT_Older - SingleNaming_OBJECT_Older)
#get means across participants
tableS1mixswitch[2,2] <- 100*mean(means_LS_acc_allcombs_pivot$MixingCostOlderAction, na.rm=TRUE)
tableS1mixswitchSD[2,2] <- 100*sd(means_LS_acc_allcombs_pivot$MixingCostOlderAction, na.rm=TRUE)
tableS1mixswitch[1,2] <- 100*mean(means_LS_acc_allcombs_pivot$MixingCostOlderObject, na.rm=TRUE)
tableS1mixswitchSD[1,2] <- 100*sd(means_LS_acc_allcombs_pivot$MixingCostOlderObject, na.rm=TRUE)
tableS1mixswitch[2,1] <- 100*mean(means_LS_acc_allcombs_pivot$MixingCostYoungerAction, na.rm=TRUE)
tableS1mixswitchSD[2,1] <- 100*sd(means_LS_acc_allcombs_pivot$MixingCostYoungerAction, na.rm=TRUE)
tableS1mixswitch[1,1] <- 100*mean(means_LS_acc_allcombs_pivot$MixingCostYoungerObject, na.rm=TRUE)
tableS1mixswitchSD[1,1] <- 100*sd(means_LS_acc_allcombs_pivot$MixingCostYoungerObject, na.rm=TRUE) 

###accuracy means for Supplementary Table 3
####get means for Table per combination of conditions
#get participant mean per trial type & rule
means_NLS_acc_allcombs <- NLS_Exp1 %>% 
  group_by(participant, TrialType, Rule, AgeGroup) %>% 
  summarise(meanacc_all = mean(accuracy01))

head(means_NLS_acc_allcombs)
#get means across participants
tableS3means <- aggregate(meanacc_all~AgeGroup+Rule+TrialType, data=means_NLS_acc_allcombs, mean, na.rm=TRUE)
tableS3SDs <- aggregate(meanacc_all~AgeGroup+Rule+TrialType, data=means_NLS_acc_allcombs, sd, na.rm=TRUE)

tableS3mixswitch <- matrix(0,nrow=4,ncol=2)
tableS3mixswitchSD <- matrix(0,nrow=4,ncol=2)

#get mixing & switching costs
means_NLS_acc_allcombs_pivot <- means_NLS_acc_allcombs %>% 
  pivot_wider(id_cols = participant, names_from = c(TrialType,Rule,AgeGroup), values_from = meanacc_all)

head(means_NLS_acc_allcombs_pivot)
#switching cost per combi
means_NLS_acc_allcombs_pivot <- means_NLS_acc_allcombs_pivot %>% 
  mutate(SwitchingCostYoungerPARITY = switch_PARITY_Younger - nonswitch_PARITY_Younger,
         SwitchingCostOlderPARITY = switch_PARITY_Older - nonswitch_PARITY_Older,
         SwitchingCostYoungerSIZE = switch_SIZE_Younger - nonswitch_SIZE_Younger,
         SwitchingCostOlderSIZE = switch_SIZE_Older - nonswitch_SIZE_Older)
#get means across participants
tableS3mixswitch[4,2] <- 100*mean(means_NLS_acc_allcombs_pivot$SwitchingCostOlderPARITY, na.rm=TRUE)
tableS3mixswitchSD[4,2] <- 100*sd(means_NLS_acc_allcombs_pivot$SwitchingCostOlderPARITY, na.rm=TRUE)
tableS3mixswitch[3,2] <- 100*mean(means_NLS_acc_allcombs_pivot$SwitchingCostOlderSIZE, na.rm=TRUE)
tableS3mixswitchSD[3,2] <- 100*sd(means_NLS_acc_allcombs_pivot$SwitchingCostOlderSIZE, na.rm=TRUE)
tableS3mixswitch[4,1] <- 100*mean(means_NLS_acc_allcombs_pivot$SwitchingCostYoungerPARITY, na.rm=TRUE)
tableS3mixswitchSD[4,1] <- 100*sd(means_NLS_acc_allcombs_pivot$SwitchingCostYoungerPARITY, na.rm=TRUE)
tableS3mixswitch[3,1] <- 100*mean(means_NLS_acc_allcombs_pivot$SwitchingCostYoungerSIZE, na.rm=TRUE)
tableS3mixswitchSD[3,1] <- 100*sd(means_NLS_acc_allcombs_pivot$SwitchingCostYoungerSIZE, na.rm=TRUE) 

#mixing cost per combi
means_NLS_acc_allcombs_pivot <- means_NLS_acc_allcombs_pivot %>% 
  mutate(MixingCostYoungerPARITY = nonswitch_PARITY_Younger - SingleNaming_PARITY_Younger,
         MixingCostOlderPARITY = nonswitch_PARITY_Older - SingleNaming_PARITY_Older,
         MixingCostYoungerSIZE = nonswitch_SIZE_Younger - SingleNaming_SIZE_Younger,
         MixingCostOlderSIZE = nonswitch_SIZE_Older - SingleNaming_SIZE_Older)
#get means across participants
tableS3mixswitch[2,2] <- 100*mean(means_NLS_acc_allcombs_pivot$MixingCostOlderPARITY, na.rm=TRUE)
tableS3mixswitchSD[2,2] <- 100*sd(means_NLS_acc_allcombs_pivot$MixingCostOlderPARITY, na.rm=TRUE)
tableS3mixswitch[1,2] <- 100*mean(means_NLS_acc_allcombs_pivot$MixingCostOlderSIZE, na.rm=TRUE)
tableS3mixswitchSD[1,2] <- 100*sd(means_NLS_acc_allcombs_pivot$MixingCostOlderSIZE, na.rm=TRUE)
tableS3mixswitch[2,1] <- 100*mean(means_NLS_acc_allcombs_pivot$MixingCostYoungerPARITY, na.rm=TRUE)
tableS3mixswitchSD[2,1] <- 100*sd(means_NLS_acc_allcombs_pivot$MixingCostYoungerPARITY, na.rm=TRUE)
tableS3mixswitch[1,1] <- 100*mean(means_NLS_acc_allcombs_pivot$MixingCostYoungerSIZE, na.rm=TRUE)
tableS3mixswitchSD[1,1] <- 100*sd(means_NLS_acc_allcombs_pivot$MixingCostYoungerSIZE, na.rm=TRUE) 

##correlations
cor1output <- cor.test(means_NLS_Exp1_Costs_pivot$SwitchingCost, means_LS_Exp1_Costs_pivot$SwitchingCost, method=c("pearson")) #switching cost for non-linguistic & noun-verb
cor2output <- cor.test(means_NLS_Exp1_Costs_pivot$MixingCost, means_LS_Exp1_Costs_pivot$MixingCost, method=c("pearson")) #Mixing cost for non-linguistic & noun-verb

Zscore_NLS <- summary(lme_NLS_Exp1_mixing_2_zscore_conv)
```

```{r extractexpt2results, include=FALSE}
####Correlational analysis Exp 2 ####
#get bilingual switching & mixing cost
#get participant mean per trial type
means_Bil_Exp2_Costs <- Bilingual_Exp2_acc_outliers %>% 
  group_by(participant, Trialtype) %>% 
  summarise(meanRT_all = mean(rawrt))

#get mixing & switching costs
means_Bil_Exp2_Costs_pivot <- means_Bil_Exp2_Costs %>% 
  pivot_wider(id_cols = participant, names_from = c(Trialtype), values_from = meanRT_all)

head(means_Bil_Exp2_Costs_pivot)
#switching cost per participant
means_Bil_Exp2_Costs_pivot <- means_Bil_Exp2_Costs_pivot %>% 
  mutate(SwitchingCost = switch - nonswitch)
#mixing cost per participant
means_Bil_Exp2_Costs_pivot <- means_Bil_Exp2_Costs_pivot %>% 
  mutate(MixingCost = nonswitch - SingleNaming)


##get noun-verb switching & mixing cost
means_NV_Exp2_Costs <- NounVerb_Exp2_acc_outliers %>% 
  group_by(participant, TrialType) %>% 
  summarise(meanRT_all = mean(rawrt))

#get mixing & switching costs
means_NV_Exp2_Costs_pivot <- means_NV_Exp2_Costs %>% 
  pivot_wider(id_cols = participant, names_from = c(TrialType), values_from = meanRT_all)

head(means_NV_Exp2_Costs_pivot)
#switching cost per participant
means_NV_Exp2_Costs_pivot <- means_NV_Exp2_Costs_pivot %>% 
  mutate(SwitchingCost = switch - nonswitch)
#mixing cost per participant
means_NV_Exp2_Costs_pivot <- means_NV_Exp2_Costs_pivot %>% 
  mutate(MixingCost = nonswitch - SingleNaming)

##get semantic control cost
means_Semantic_Exp2_Costs <- Semantic_Exp2_acc_outliers %>% 
  group_by(participant, control) %>% 
  summarise(meanRT_all = mean(rawrt))

means_Semantic_Exp2_Costs_pivot <- means_Semantic_Exp2_Costs %>% 
  pivot_wider(id_cols = participant, names_from = c(control), values_from = meanRT_all)
head(means_Semantic_Exp2_Costs_pivot)
means_Semantic_Exp2_Costs_pivot <- means_Semantic_Exp2_Costs_pivot %>% 
  mutate(SemanticCost = incon-cong)

##correlations
corBNVswitchoutput <- cor.test(means_Bil_Exp2_Costs_pivot$SwitchingCost, means_NV_Exp2_Costs_pivot$SwitchingCost, method=c("pearson")) #switching cost for bilingual & noun-verb
corBNVmixoutput <-cor.test(means_Bil_Exp2_Costs_pivot$MixingCost, means_NV_Exp2_Costs_pivot$MixingCost, method=c("pearson")) #Mixing cost for bilingual & noun-verb

means_Bil_Exp2_Costs_pivot_corr<- subset(means_Bil_Exp2_Costs_pivot, means_Bil_Exp2_Costs_pivot$participant!="54")
means_NV_Exp2_Costs_pivot_corr<- subset(means_NV_Exp2_Costs_pivot, means_NV_Exp2_Costs_pivot$participant!="54")

corSemanticBiloutput <- cor.test(means_Bil_Exp2_Costs_pivot_corr$SwitchingCost, means_Semantic_Exp2_Costs_pivot$SemanticCost, method=c("pearson")) #switching cost for bilingual & semantic
corSemanticNVoutput <- cor.test(means_NV_Exp2_Costs_pivot_corr$SwitchingCost, means_Semantic_Exp2_Costs_pivot$SemanticCost, method=c("pearson")) #Switching cost for noun-verb & semantic


####get means for results section ####
#get participant mean per trial type
means_Bil_2 <- Bilingual_Exp2_acc_outliers %>% 
  group_by(participant, Trialtype) %>% 
  summarise(meanRT = mean(rawrt))

head(means_Bil_2)

#get means & SD across participants per trial type
Bil_Trialtype_RT_M <- aggregate(meanRT~Trialtype, data=means_Bil_2, mean, na.rm=TRUE)
Bil_Trialtype_RT_SD <- aggregate(meanRT~Trialtype, data=means_Bil_2, sd, na.rm=TRUE)

#get participant mean per age group for switching analysis
means_Bil2_age <- Bilingual_Exp2_acc_outliers_switching %>% 
  group_by(participant, Agegroup) %>% 
  summarise(meanRT = mean(rawrt))
head(means_Bil2_age)
Bil_Age_RT_M <- aggregate(meanRT~Agegroup, data=means_Bil2_age, mean, na.rm=TRUE)
Bil_Age_RT_SD <-aggregate(meanRT~Agegroup, data=means_Bil2_age, sd, na.rm=TRUE)

#get participant mean per age group for mixing analysis
means_Bil2_age_mix <- Bilingual_Exp2_acc_outliers_mixing %>% 
  group_by(participant, Agegroup) %>% 
  summarise(meanRT = mean(rawrt))
head(means_Bil2_age_mix)
Bil_AgeMix_RT_M <- aggregate(meanRT~Agegroup, data=means_Bil2_age_mix, mean, na.rm=TRUE)
Bil_AgeMix_RT_SD <-aggregate(meanRT~Agegroup, data=means_Bil2_age_mix, sd, na.rm=TRUE)

#get participant mean per language for mixing analysis
means_Bil2_lang_mix <- Bilingual_Exp2_acc_outliers_mixing %>% 
  group_by(participant, Language) %>% 
  summarise(meanRT = mean(rawrt))
head(means_Bil2_lang_mix)
Bil_LangMix_RT_M <-aggregate(meanRT~Language, data=means_Bil2_lang_mix, mean, na.rm=TRUE)
Bil_LangMix_RT_SD <- aggregate(meanRT~Language, data=means_Bil2_lang_mix, sd, na.rm=TRUE)

#mixing cost per language, across age groups
means_Bil2_Lang_mix_acrossage <- Bilingual_Exp2_acc_outliers_mixing %>% 
  group_by(participant, Language, Trialtype) %>% 
  summarise(meanRT = mean(rawrt))
head(means_Bil2_Lang_mix_acrossage)

means_Bil2_Lang_mix_acrossage_pivot <- means_Bil2_Lang_mix_acrossage %>% 
  pivot_wider(id_cols = participant, names_from = c(Language, Trialtype), values_from = meanRT)

head(means_Bil2_Lang_mix_acrossage_pivot)

means_Bil2_Lang_mix_acrossage_pivot <- means_Bil2_Lang_mix_acrossage_pivot %>% 
  mutate(MixingCostL1 = L1_nonswitch - L1_SingleNaming,
         MixingCostL2 = L2_nonswitch - L2_SingleNaming)
Bil_L1Mix_RT_M <-mean(means_Bil2_Lang_mix_acrossage_pivot$MixingCostL1, na.rm=TRUE)
Bil_L1Mix_RT_SD <-sd(means_Bil2_Lang_mix_acrossage_pivot$MixingCostL1, na.rm=TRUE)
Bil_L2Mix_RT_M <-mean(means_Bil2_Lang_mix_acrossage_pivot$MixingCostL2, na.rm=TRUE)
Bil_L2Mix_RT_SD <-sd(means_Bil2_Lang_mix_acrossage_pivot$MixingCostL2, na.rm=TRUE)



####get means for Table 5 ####
#get participant mean per trial type
means_Bil_Exp2_allcombs <- Bilingual_Exp2_acc_outliers %>% 
  group_by(participant, Trialtype, Language, Agegroup) %>% 
  summarise(meanRT_all = mean(rawrt))

head(means_Bil_Exp2_allcombs)
#get means across participants
aggregate(meanRT_all~Agegroup+Language+Trialtype, data=means_Bil_Exp2_allcombs, mean, na.rm=TRUE)
aggregate(meanRT_all~Agegroup+Language+Trialtype, data=means_Bil_Exp2_allcombs, sd, na.rm=TRUE)


#get mixing & switching costs
means_Bil_Exp2_allcombs_pivot <- means_Bil_Exp2_allcombs %>% 
  pivot_wider(id_cols = participant, names_from = c(Trialtype,Language,Agegroup), values_from = meanRT_all)

head(means_Bil_Exp2_allcombs_pivot)

table5means <- matrix(0,nrow=15,ncol=2)
table5SDs <- matrix(0,nrow=15,ncol=2)

table5means[1,2] <- mean(means_Bil_Exp2_allcombs_pivot$SingleNaming_L1_Older, na.rm=TRUE)
table5SDs[1,2] <- sd(means_Bil_Exp2_allcombs_pivot$SingleNaming_L1_Older, na.rm=TRUE)
table5means[2,2] <- mean(means_Bil_Exp2_allcombs_pivot$SingleNaming_L2_Older, na.rm=TRUE)
table5SDs[2,2] <- sd(means_Bil_Exp2_allcombs_pivot$SingleNaming_L2_Older, na.rm=TRUE)

table5means[3,2] <- mean(means_Bil_Exp2_allcombs_pivot$nonswitch_L1_Older, na.rm=TRUE)
table5SDs[3,2] <- sd(means_Bil_Exp2_allcombs_pivot$nonswitch_L1_Older, na.rm=TRUE)
table5means[4,2] <- mean(means_Bil_Exp2_allcombs_pivot$nonswitch_L2_Older, na.rm=TRUE)
table5SDs[4,2] <- sd(means_Bil_Exp2_allcombs_pivot$nonswitch_L2_Older, na.rm=TRUE)

table5means[5,2] <- mean(means_Bil_Exp2_allcombs_pivot$switch_L1_Older, na.rm=TRUE)
table5SDs[5,2] <- sd(means_Bil_Exp2_allcombs_pivot$switch_L1_Older, na.rm=TRUE)
table5means[6,2] <- mean(means_Bil_Exp2_allcombs_pivot$switch_L2_Older, na.rm=TRUE)
table5SDs[6,2] <- sd(means_Bil_Exp2_allcombs_pivot$switch_L2_Older, na.rm=TRUE)

table5means[1,1] <- mean(means_Bil_Exp2_allcombs_pivot$SingleNaming_L1_Younger, na.rm=TRUE)
table5SDs[1,1] <- sd(means_Bil_Exp2_allcombs_pivot$SingleNaming_L1_Younger, na.rm=TRUE)
table5means[2,1] <- mean(means_Bil_Exp2_allcombs_pivot$SingleNaming_L2_Younger, na.rm=TRUE)
table5SDs[2,1] <- sd(means_Bil_Exp2_allcombs_pivot$SingleNaming_L2_Younger, na.rm=TRUE)

table5means[3,1] <- mean(means_Bil_Exp2_allcombs_pivot$nonswitch_L1_Younger, na.rm=TRUE)
table5SDs[3,1] <- sd(means_Bil_Exp2_allcombs_pivot$nonswitch_L1_Younger, na.rm=TRUE)
table5means[4,1] <- mean(means_Bil_Exp2_allcombs_pivot$nonswitch_L2_Younger, na.rm=TRUE)
table5SDs[4,1] <- sd(means_Bil_Exp2_allcombs_pivot$nonswitch_L2_Younger, na.rm=TRUE)

table5means[5,1] <- mean(means_Bil_Exp2_allcombs_pivot$switch_L1_Younger, na.rm=TRUE)
table5SDs[5,1] <- sd(means_Bil_Exp2_allcombs_pivot$switch_L1_Younger, na.rm=TRUE)
table5means[6,1] <- mean(means_Bil_Exp2_allcombs_pivot$switch_L2_Younger, na.rm=TRUE)
table5SDs[6,1] <- sd(means_Bil_Exp2_allcombs_pivot$switch_L2_Younger, na.rm=TRUE)


#switching cost per combi
means_Bil_Exp2_allcombs_pivot <- means_Bil_Exp2_allcombs_pivot %>% 
  mutate(SwitchingCostYoungerL2 = switch_L2_Younger - nonswitch_L2_Younger,
         SwitchingCostOlderL2 = switch_L2_Older - nonswitch_L2_Older,
         SwitchingCostYoungerL1 = switch_L1_Younger - nonswitch_L1_Younger,
         SwitchingCostOlderL1 = switch_L1_Older - nonswitch_L1_Older)
#get means across participants
table5means[10,2] <-mean(means_Bil_Exp2_allcombs_pivot$SwitchingCostOlderL2, na.rm=TRUE)
table5SDs[10,2] <-sd(means_Bil_Exp2_allcombs_pivot$SwitchingCostOlderL2, na.rm=TRUE)
table5means[9,2] <-mean(means_Bil_Exp2_allcombs_pivot$SwitchingCostOlderL1, na.rm=TRUE)
table5SDs[9,2] <-sd(means_Bil_Exp2_allcombs_pivot$SwitchingCostOlderL1, na.rm=TRUE)
table5means[10,1] <-mean(means_Bil_Exp2_allcombs_pivot$SwitchingCostYoungerL2, na.rm=TRUE)
table5SDs[10,1] <-sd(means_Bil_Exp2_allcombs_pivot$SwitchingCostYoungerL2, na.rm=TRUE)
table5means[9,1] <-mean(means_Bil_Exp2_allcombs_pivot$SwitchingCostYoungerL1, na.rm=TRUE)
table5SDs[9,1] <-sd(means_Bil_Exp2_allcombs_pivot$SwitchingCostYoungerL1, na.rm=TRUE)

#mixing costs per combi
means_Bil_Exp2_allcombs_pivot <- means_Bil_Exp2_allcombs_pivot %>% 
  mutate(MixingCostYoungerL2 = nonswitch_L2_Younger - SingleNaming_L2_Younger,
         MixingCostOlderL2 = nonswitch_L2_Older - SingleNaming_L2_Older,
         MixingCostYoungerL1 = nonswitch_L1_Younger - SingleNaming_L1_Younger,
         MixingCostOlderL1 = nonswitch_L1_Older - SingleNaming_L1_Older)
#get means across participants
table5means[8,2] <-mean(means_Bil_Exp2_allcombs_pivot$MixingCostOlderL2, na.rm=TRUE)
table5SDs[8,2] <-sd(means_Bil_Exp2_allcombs_pivot$MixingCostOlderL2, na.rm=TRUE)
table5means[7,2] <-mean(means_Bil_Exp2_allcombs_pivot$MixingCostOlderL1, na.rm=TRUE)
table5SDs[7,2] <-sd(means_Bil_Exp2_allcombs_pivot$MixingCostOlderL1, na.rm=TRUE)
table5means[8,1] <-mean(means_Bil_Exp2_allcombs_pivot$MixingCostYoungerL2, na.rm=TRUE)
table5SDs[8,1] <-sd(means_Bil_Exp2_allcombs_pivot$MixingCostYoungerL2, na.rm=TRUE)
table5means[7,1] <-mean(means_Bil_Exp2_allcombs_pivot$MixingCostYoungerL1, na.rm=TRUE)
table5SDs[7,1] <-sd(means_Bil_Exp2_allcombs_pivot$MixingCostYoungerL1, na.rm=TRUE)


#### get means for results section Noun-verb task ####
#get participant mean per trial type
means_NV_Exp2 <- NounVerb_Exp2_acc_outliers %>% 
  group_by(participant, TrialType) %>% 
  summarise(meanRT = mean(rawrt))

head(means_NV_Exp2)
#get means & SD across participants per trial type
NV_Trialtype_RT_M <- aggregate(meanRT~TrialType, data=means_NV_Exp2, mean, na.rm=TRUE)
NV_Trialtype_RT_SD <- aggregate(meanRT~TrialType, data=means_NV_Exp2, sd, na.rm=TRUE)

#get participant mean per rule for mixing analysis
means_NV_Exp2_rule_mix <- NounVerb_Exp2_acc_outliers_mixing %>% 
  group_by(participant, Rule) %>% 
  summarise(meanRT = mean(rawrt))
head(means_NV_Exp2_rule_mix)
NV_RuleMix_RT_M <- aggregate(meanRT~Rule, data=means_NV_Exp2_rule_mix, mean, na.rm=TRUE)
NV_RuleMix_RT_SD <- aggregate(meanRT~Rule, data=means_NV_Exp2_rule_mix, sd, na.rm=TRUE)

#mixing cost per rule, across age groups
means_NV_Exp2_rulegeneral_mix <- NounVerb_Exp2_acc_outliers_mixing %>% 
  group_by(participant, Rule, TrialType) %>% 
  summarise(meanRT = mean(rawrt))
head(means_NV_Exp2_rulegeneral_mix)

means_NV_Exp2_rulegeneral_mix_pivot <- means_NV_Exp2_rulegeneral_mix %>% 
  pivot_wider(id_cols = participant, names_from = c(Rule, TrialType), values_from = meanRT)

head(means_NV_Exp2_rulegeneral_mix_pivot)

means_NV_Exp2_rulegeneral_mix_pivot <- means_NV_Exp2_rulegeneral_mix_pivot %>% 
  mutate(MixingCostAction = ACTION_nonswitch - ACTION_SingleNaming,
         MixingCostObject = OBJECT_nonswitch - OBJECT_SingleNaming)
NV_MixingAction_RT_M <-mean(means_NV_Exp2_rulegeneral_mix_pivot$MixingCostAction, na.rm=TRUE)
NV_MixingAction_RT_SD <-sd(means_NV_Exp2_rulegeneral_mix_pivot$MixingCostAction, na.rm=TRUE)
NV_MixingObject_RT_M <-mean(means_NV_Exp2_rulegeneral_mix_pivot$MixingCostObject, na.rm=TRUE)
NV_MixingObject_RT_SD <-sd(means_NV_Exp2_rulegeneral_mix_pivot$MixingCostObject, na.rm=TRUE)


#### get means for Table 7 ####
#get participant mean per trial type
means_NV_Exp2_allcombs <- NounVerb_Exp2_acc_outliers %>% 
  group_by(participant, TrialType, Rule, Agegroup) %>% 
  summarise(meanRT_all = mean(rawrt))

head(means_NV_Exp2_allcombs)
#get means across participants
aggregate(meanRT_all~Agegroup+Rule+TrialType, data=means_NV_Exp2_allcombs, mean, na.rm=TRUE)
aggregate(meanRT_all~Agegroup+Rule+TrialType, data=means_NV_Exp2_allcombs, sd, na.rm=TRUE)

#get mixing & switching costs
means_NV_Exp2_allcombs_pivot <- means_NV_Exp2_allcombs %>% 
  pivot_wider(id_cols = participant, names_from = c(TrialType,Rule,Agegroup), values_from = meanRT_all)

head(means_NV_Exp2_allcombs_pivot)

table7means <- matrix(0,nrow=15,ncol=2)
table7SDs <- matrix(0,nrow=15,ncol=2)

table7means[1,2] <- mean(means_NV_Exp2_allcombs_pivot$SingleNaming_OBJECT_Older, na.rm=TRUE)
table7SDs[1,2] <- sd(means_NV_Exp2_allcombs_pivot$SingleNaming_OBJECT_Older, na.rm=TRUE)
table7means[2,2] <- mean(means_NV_Exp2_allcombs_pivot$SingleNaming_ACTION_Older, na.rm=TRUE)
table7SDs[2,2] <- sd(means_NV_Exp2_allcombs_pivot$SingleNaming_ACTION_Older, na.rm=TRUE)

table7means[3,2] <- mean(means_NV_Exp2_allcombs_pivot$nonswitch_OBJECT_Older, na.rm=TRUE)
table7SDs[3,2] <- sd(means_NV_Exp2_allcombs_pivot$nonswitch_OBJECT_Older, na.rm=TRUE)
table7means[4,2] <- mean(means_NV_Exp2_allcombs_pivot$nonswitch_ACTION_Older, na.rm=TRUE)
table7SDs[4,2] <- sd(means_NV_Exp2_allcombs_pivot$nonswitch_ACTION_Older, na.rm=TRUE)

table7means[5,2] <- mean(means_NV_Exp2_allcombs_pivot$switch_OBJECT_Older, na.rm=TRUE)
table7SDs[5,2] <- sd(means_NV_Exp2_allcombs_pivot$switch_OBJECT_Older, na.rm=TRUE)
table7means[6,2] <- mean(means_NV_Exp2_allcombs_pivot$switch_ACTION_Older, na.rm=TRUE)
table7SDs[6,2] <- sd(means_NV_Exp2_allcombs_pivot$switch_ACTION_Older, na.rm=TRUE)

table7means[1,1] <- mean(means_NV_Exp2_allcombs_pivot$SingleNaming_OBJECT_Younger, na.rm=TRUE)
table7SDs[1,1] <- sd(means_NV_Exp2_allcombs_pivot$SingleNaming_OBJECT_Younger, na.rm=TRUE)
table7means[2,1] <- mean(means_NV_Exp2_allcombs_pivot$SingleNaming_ACTION_Younger, na.rm=TRUE)
table7SDs[2,1] <- sd(means_NV_Exp2_allcombs_pivot$SingleNaming_ACTION_Younger, na.rm=TRUE)

table7means[3,1] <- mean(means_NV_Exp2_allcombs_pivot$nonswitch_OBJECT_Younger, na.rm=TRUE)
table7SDs[3,1] <- sd(means_NV_Exp2_allcombs_pivot$nonswitch_OBJECT_Younger, na.rm=TRUE)
table7means[4,1] <- mean(means_NV_Exp2_allcombs_pivot$nonswitch_ACTION_Younger, na.rm=TRUE)
table7SDs[4,1] <- sd(means_NV_Exp2_allcombs_pivot$nonswitch_ACTION_Younger, na.rm=TRUE)

table7means[5,1] <- mean(means_NV_Exp2_allcombs_pivot$switch_OBJECT_Younger, na.rm=TRUE)
table7SDs[5,1] <- sd(means_NV_Exp2_allcombs_pivot$switch_OBJECT_Younger, na.rm=TRUE)
table7means[6,1] <- mean(means_NV_Exp2_allcombs_pivot$switch_ACTION_Younger, na.rm=TRUE)
table7SDs[6,1] <- sd(means_NV_Exp2_allcombs_pivot$switch_ACTION_Younger, na.rm=TRUE)

#switching cost per combi
means_NV_Exp2_allcombs_pivot <- means_NV_Exp2_allcombs_pivot %>% 
  mutate(SwitchingCostYoungerAction = switch_ACTION_Younger - nonswitch_ACTION_Younger,
         SwitchingCostOlderAction = switch_ACTION_Older - nonswitch_ACTION_Older,
         SwitchingCostYoungerObject = switch_OBJECT_Younger - nonswitch_OBJECT_Younger,
         SwitchingCostOlderObject = switch_OBJECT_Older - nonswitch_OBJECT_Older)
#get means across participants
table7means[10,2] <-mean(means_NV_Exp2_allcombs_pivot$SwitchingCostOlderAction, na.rm=TRUE)
table7SDs[10,2] <-sd(means_NV_Exp2_allcombs_pivot$SwitchingCostOlderAction, na.rm=TRUE)
table7means[9,2] <-mean(means_NV_Exp2_allcombs_pivot$SwitchingCostOlderObject, na.rm=TRUE)
table7SDs[9,2] <-sd(means_NV_Exp2_allcombs_pivot$SwitchingCostOlderObject, na.rm=TRUE)
table7means[10,1] <-mean(means_NV_Exp2_allcombs_pivot$SwitchingCostYoungerAction, na.rm=TRUE)
table7SDs[10,1] <-sd(means_NV_Exp2_allcombs_pivot$SwitchingCostYoungerAction, na.rm=TRUE)
table7means[9,1] <-mean(means_NV_Exp2_allcombs_pivot$SwitchingCostYoungerObject, na.rm=TRUE)
table7SDs[9,1] <-sd(means_NV_Exp2_allcombs_pivot$SwitchingCostYoungerObject, na.rm=TRUE)

#mixing costs per combi
means_NV_Exp2_allcombs_pivot <- means_NV_Exp2_allcombs_pivot %>% 
  mutate(MixingCostYoungerAction = nonswitch_ACTION_Younger - SingleNaming_ACTION_Younger,
         MixingCostOlderAction = nonswitch_ACTION_Older - SingleNaming_ACTION_Older,
         MixingCostYoungerObject = nonswitch_OBJECT_Younger - SingleNaming_OBJECT_Younger,
         MixingCostOlderObject = nonswitch_OBJECT_Older - SingleNaming_OBJECT_Older)
#get means across participants
table7means[8,2] <-mean(means_NV_Exp2_allcombs_pivot$MixingCostOlderAction, na.rm=TRUE)
table7SDs[8,2] <-sd(means_NV_Exp2_allcombs_pivot$MixingCostOlderAction, na.rm=TRUE)
table7means[7,2] <-mean(means_NV_Exp2_allcombs_pivot$MixingCostOlderObject, na.rm=TRUE)
table7SDs[7,2] <-sd(means_NV_Exp2_allcombs_pivot$MixingCostOlderObject, na.rm=TRUE)
table7means[8,1] <-mean(means_NV_Exp2_allcombs_pivot$MixingCostYoungerAction, na.rm=TRUE)
table7SDs[8,1] <-sd(means_NV_Exp2_allcombs_pivot$MixingCostYoungerAction, na.rm=TRUE)
table7means[7,1] <-mean(means_NV_Exp2_allcombs_pivot$MixingCostYoungerObject, na.rm=TRUE)
table7SDs[7,1] <-sd(means_NV_Exp2_allcombs_pivot$MixingCostYoungerObject, na.rm=TRUE)


####get means for results section semantic control
#get participant mean per trial type
means_Semantic_Exp2 <- Semantic_Exp2_acc_outliers %>% 
  group_by(participant, control) %>% 
  summarise(meanRT = mean(rawrt))

head(means_Semantic_Exp2)
#get means & SD across participants per trial type
Semantic_RT_M <-aggregate(meanRT~control, data=means_Semantic_Exp2, mean, na.rm=TRUE)
Semantic_RT_SD <-aggregate(meanRT~control, data=means_Semantic_Exp2, sd, na.rm=TRUE)


#get participant mean per age group
means_Semantic_Exp2_age <- Semantic_Exp2_acc_outliers %>% 
  group_by(participant, AgeGroup) %>% 
  summarise(meanRT = mean(rawrt))

head(means_Semantic_Exp2_age)
#get means & SD across participants per trial type
Semantic_RTAge_M <- aggregate(meanRT~AgeGroup, data=means_Semantic_Exp2_age, mean, na.rm=TRUE)
Semantic_RTAge_SD <- aggregate(meanRT~AgeGroup, data=means_Semantic_Exp2_age, sd, na.rm=TRUE)

#get participant mean per trial type
means_Semantic_Exp2_cost <- Semantic_Exp2_acc_outliers %>% 
  group_by(participant, control, AgeGroup) %>% 
  summarise(meanRT_all = mean(rawrt))
head(means_Semantic_Exp2_cost)

means_Semantic_Exp2_cost_pivot <- means_Semantic_Exp2_cost %>% 
  pivot_wider(id_cols = participant, names_from = c(control,AgeGroup), values_from = meanRT_all)
head(means_Semantic_Exp2_cost_pivot)

means_Semantic_Exp2_cost_pivot <- means_Semantic_Exp2_cost_pivot %>% 
  mutate(CostYounger = incon_Younger - cong_Younger,
         CostOlder = incon_Older - cong_Older)
#get means across participants
Semantic_CostYoung_M <-mean(means_Semantic_Exp2_cost_pivot$CostYounger, na.rm=TRUE)
Semantic_CostYoung_SD <-sd(means_Semantic_Exp2_cost_pivot$CostYounger, na.rm=TRUE)
Semantic_CostOld_M <-mean(means_Semantic_Exp2_cost_pivot$CostOlder, na.rm=TRUE)
Semantic_CostOld_SD <-sd(means_Semantic_Exp2_cost_pivot$CostOlder, na.rm=TRUE)

#get coefficients for in text reporting
SemControl <- summary(lme_semantic_Exp2)
MixingTask <-summary(lme_TaskComp_Exp2_mixing_2)

###accuracy means for Supplementary Table 7
####get means for Table per combination of conditions
#get participant mean per trial type & rule
means_BilExp2_acc_allcombs <- Bilingual_Exp2 %>% 
  group_by(participant, Trialtype, Language, Agegroup) %>% 
  summarise(meanacc_all = mean(accuracy01))

head(means_BilExp2_acc_allcombs)
#get means across participants
tableS7means <- aggregate(meanacc_all~Agegroup+Language+Trialtype, data=means_BilExp2_acc_allcombs, mean, na.rm=TRUE)
tableS7SDs <- aggregate(meanacc_all~Agegroup+Language+Trialtype, data=means_BilExp2_acc_allcombs, sd, na.rm=TRUE)

tableS7mixswitch <- matrix(0,nrow=4,ncol=2)
tableS7mixswitchSD <- matrix(0,nrow=4,ncol=2)

#get mixing & switching costs
means_BilExp2_acc_allcombs_pivot <- means_BilExp2_acc_allcombs %>% 
  pivot_wider(id_cols = participant, names_from = c(Trialtype,Language,Agegroup), values_from = meanacc_all)

head(means_BilExp2_acc_allcombs_pivot)
#switching cost per combi
means_BilExp2_acc_allcombs_pivot <- means_BilExp2_acc_allcombs_pivot %>% 
  mutate(SwitchingCostYoungerL2 = switch_L2_Younger - nonswitch_L2_Younger,
         SwitchingCostOlderL2 = switch_L2_Older - nonswitch_L2_Older,
         SwitchingCostYoungerL1 = switch_L1_Younger - nonswitch_L1_Younger,
         SwitchingCostOlderL1 = switch_L1_Older - nonswitch_L1_Older)
#get means across participants
tableS7mixswitch[4,2] <- 100*mean(means_BilExp2_acc_allcombs_pivot$SwitchingCostOlderL2, na.rm=TRUE)
tableS7mixswitchSD[4,2] <- 100*sd(means_BilExp2_acc_allcombs_pivot$SwitchingCostOlderL2, na.rm=TRUE)
tableS7mixswitch[3,2] <- 100*mean(means_BilExp2_acc_allcombs_pivot$SwitchingCostOlderL1, na.rm=TRUE)
tableS7mixswitchSD[3,2] <- 100*sd(means_BilExp2_acc_allcombs_pivot$SwitchingCostOlderL1, na.rm=TRUE)
tableS7mixswitch[4,1] <- 100*mean(means_BilExp2_acc_allcombs_pivot$SwitchingCostYoungerL2, na.rm=TRUE)
tableS7mixswitchSD[4,1] <- 100*sd(means_BilExp2_acc_allcombs_pivot$SwitchingCostYoungerL2, na.rm=TRUE)
tableS7mixswitch[3,1] <- 100*mean(means_BilExp2_acc_allcombs_pivot$SwitchingCostYoungerL1, na.rm=TRUE)
tableS7mixswitchSD[3,1] <- 100*sd(means_BilExp2_acc_allcombs_pivot$SwitchingCostYoungerL1, na.rm=TRUE) 

#mixing cost per combi
means_BilExp2_acc_allcombs_pivot <- means_BilExp2_acc_allcombs_pivot %>% 
  mutate(MixingCostYoungerL2 = nonswitch_L2_Younger - SingleNaming_L2_Younger,
         MixingCostOlderL2 = nonswitch_L2_Older - SingleNaming_L2_Older,
         MixingCostYoungerL1 = nonswitch_L1_Younger - SingleNaming_L1_Younger,
         MixingCostOlderL1 = nonswitch_L1_Older - SingleNaming_L1_Older)
#get means across participants
tableS7mixswitch[2,2] <- 100*mean(means_BilExp2_acc_allcombs_pivot$MixingCostOlderL2, na.rm=TRUE)
tableS7mixswitchSD[2,2] <- 100*sd(means_BilExp2_acc_allcombs_pivot$MixingCostOlderL2, na.rm=TRUE)
tableS7mixswitch[1,2] <- 100*mean(means_BilExp2_acc_allcombs_pivot$MixingCostOlderL1, na.rm=TRUE)
tableS7mixswitchSD[1,2] <- 100*sd(means_BilExp2_acc_allcombs_pivot$MixingCostOlderL1, na.rm=TRUE)
tableS7mixswitch[2,1] <- 100*mean(means_BilExp2_acc_allcombs_pivot$MixingCostYoungerL2, na.rm=TRUE)
tableS7mixswitchSD[2,1] <- 100*sd(means_BilExp2_acc_allcombs_pivot$MixingCostYoungerL2, na.rm=TRUE)
tableS7mixswitch[1,1] <- 100*mean(means_BilExp2_acc_allcombs_pivot$MixingCostYoungerL1, na.rm=TRUE)
tableS7mixswitchSD[1,1] <- 100*sd(means_BilExp2_acc_allcombs_pivot$MixingCostYoungerL1, na.rm=TRUE) 



###accuracy means for Supplementary Table 9
####get means for Table per combination of conditions
#get participant mean per trial type & rule
means_NVExp2_acc_allcombs <- NounVerb_Exp2 %>% 
  group_by(participant, TrialType, Rule, Agegroup) %>% 
  summarise(meanacc_all = mean(accuracy01))

head(means_NVExp2_acc_allcombs)
#get means across participants
tableS9means <- aggregate(meanacc_all~Agegroup+Rule+TrialType, data=means_NVExp2_acc_allcombs, mean, na.rm=TRUE)
tableS9SDs <- aggregate(meanacc_all~Agegroup+Rule+TrialType, data=means_NVExp2_acc_allcombs, sd, na.rm=TRUE)

tableS9mixswitch <- matrix(0,nrow=4,ncol=2)
tableS9mixswitchSD <- matrix(0,nrow=4,ncol=2)

#get mixing & switching costs
means_NVExp2_acc_allcombs_pivot <- means_NVExp2_acc_allcombs %>% 
  pivot_wider(id_cols = participant, names_from = c(TrialType,Rule,Agegroup), values_from = meanacc_all)

head(means_NVExp2_acc_allcombs_pivot)
#switching cost per combi
means_NVExp2_acc_allcombs_pivot <- means_NVExp2_acc_allcombs_pivot %>% 
  mutate(SwitchingCostYoungerAction = switch_ACTION_Younger - nonswitch_ACTION_Younger,
         SwitchingCostOlderAction = switch_ACTION_Older - nonswitch_ACTION_Older,
         SwitchingCostYoungerObject = switch_OBJECT_Younger - nonswitch_OBJECT_Younger,
         SwitchingCostOlderObject = switch_OBJECT_Older - nonswitch_OBJECT_Older)
#get means across participants
tableS9mixswitch[4,2] <- 100*mean(means_NVExp2_acc_allcombs_pivot$SwitchingCostOlderAction, na.rm=TRUE)
tableS9mixswitchSD[4,2] <- 100*sd(means_NVExp2_acc_allcombs_pivot$SwitchingCostOlderAction, na.rm=TRUE)
tableS9mixswitch[3,2] <- 100*mean(means_NVExp2_acc_allcombs_pivot$SwitchingCostOlderObject, na.rm=TRUE)
tableS9mixswitchSD[3,2] <- 100*sd(means_NVExp2_acc_allcombs_pivot$SwitchingCostOlderObject, na.rm=TRUE)
tableS9mixswitch[4,1] <- 100*mean(means_NVExp2_acc_allcombs_pivot$SwitchingCostYoungerAction, na.rm=TRUE)
tableS9mixswitchSD[4,1] <- 100*sd(means_NVExp2_acc_allcombs_pivot$SwitchingCostYoungerAction, na.rm=TRUE)
tableS9mixswitch[3,1] <- 100*mean(means_NVExp2_acc_allcombs_pivot$SwitchingCostYoungerObject, na.rm=TRUE)
tableS9mixswitchSD[3,1] <- 100*sd(means_NVExp2_acc_allcombs_pivot$SwitchingCostYoungerObject, na.rm=TRUE) 

#mixing cost per combi
means_NVExp2_acc_allcombs_pivot <- means_NVExp2_acc_allcombs_pivot %>% 
  mutate(MixingCostYoungerAction = nonswitch_ACTION_Younger - SingleNaming_ACTION_Younger,
         MixingCostOlderAction = nonswitch_ACTION_Older - SingleNaming_ACTION_Older,
         MixingCostYoungerObject = nonswitch_OBJECT_Younger - SingleNaming_OBJECT_Younger,
         MixingCostOlderObject = nonswitch_OBJECT_Older - SingleNaming_OBJECT_Older)
#get means across participants
tableS9mixswitch[2,2] <- 100*mean(means_NVExp2_acc_allcombs_pivot$MixingCostOlderAction, na.rm=TRUE)
tableS9mixswitchSD[2,2] <- 100*sd(means_NVExp2_acc_allcombs_pivot$MixingCostOlderAction, na.rm=TRUE)
tableS9mixswitch[1,2] <- 100*mean(means_NVExp2_acc_allcombs_pivot$MixingCostOlderObject, na.rm=TRUE)
tableS9mixswitchSD[1,2] <- 100*sd(means_NVExp2_acc_allcombs_pivot$MixingCostOlderObject, na.rm=TRUE)
tableS9mixswitch[2,1] <- 100*mean(means_NVExp2_acc_allcombs_pivot$MixingCostYoungerAction, na.rm=TRUE)
tableS9mixswitchSD[2,1] <- 100*sd(means_NVExp2_acc_allcombs_pivot$MixingCostYoungerAction, na.rm=TRUE)
tableS9mixswitch[1,1] <- 100*mean(means_NVExp2_acc_allcombs_pivot$MixingCostYoungerObject, na.rm=TRUE)
tableS9mixswitchSD[1,1] <- 100*sd(means_NVExp2_acc_allcombs_pivot$MixingCostYoungerObject, na.rm=TRUE) 



### participant background data for Table S6

LexTale <- read.csv("data/LexTale.csv") #LexTale proficiency data
#get means
LexTaleL2_M <-aggregate(L2Lextale~AgeGroup, data=LexTale, mean, na.rm=TRUE)
LexTaleL2_SD <-aggregate(L2Lextale~AgeGroup, data=LexTale, sd, na.rm=TRUE)
LexTaleL1_M <-aggregate(EnglishLextale~AgeGroup, data=LexTale, mean, na.rm=TRUE)
LexTaleL1_SD <-aggregate(EnglishLextale~AgeGroup, data=LexTale, sd, na.rm=TRUE)

LexTale_long <- LexTale %>%
  gather(key = "Language", value = "score", EnglishLextale, L2Lextale) %>%
  convert_as_factor(Participant,Language)

#anova with age group x language
Lextaleanova <- aov(score~ AgeGroup*Language + Error(Participant/Language), LexTale_long)
summary(Lextaleanova)
#shows a main effect of age (better overall performance for older adults), Language (better L1 performance), and no interaction


Background <- read.csv("data/Background.csv") #participant language background data
#get means for self-rated proficiency
ProfSpeakingL1_M <-aggregate(L1Speak~AgeGroup, data=Background, mean, na.rm=TRUE)
ProfSpeakingL1_SD <-aggregate(L1Speak~AgeGroup, data=Background, sd, na.rm=TRUE)
ProfUnderstandingL1_M <-aggregate(L1understand~AgeGroup, data=Background, mean, na.rm=TRUE)
ProfUnderstandingL1_SD <-aggregate(L1understand~AgeGroup, data=Background, sd, na.rm=TRUE)
ProfWritingL1_M <-aggregate(L1write~AgeGroup, data=Background, mean, na.rm=TRUE)
ProfWritingL1_SD <-aggregate(L1write~AgeGroup, data=Background, sd, na.rm=TRUE)
ProfReadingL1_M <-aggregate(L1read~AgeGroup, data=Background, mean, na.rm=TRUE)
ProfReadingL1_SD <-aggregate(L1read~AgeGroup, data=Background, sd, na.rm=TRUE)

ProfSpeakingL2_M <-aggregate(L2Speak~AgeGroup, data=Background, mean, na.rm=TRUE)
ProfSpeakingL2_SD <-aggregate(L2Speak~AgeGroup, data=Background, sd, na.rm=TRUE)
ProfUnderstandingL2_M <-aggregate(L2understand~AgeGroup, data=Background, mean, na.rm=TRUE)
ProfUnderstandingL2_SD <-aggregate(L2understand~AgeGroup, data=Background, sd, na.rm=TRUE)
ProfWritingL2_M <-aggregate(L2write~AgeGroup, data=Background, mean, na.rm=TRUE)
ProfWritingL2_SD <-aggregate(L2write~AgeGroup, data=Background, sd, na.rm=TRUE)
ProfReadingL2_M <-aggregate(L2read~AgeGroup, data=Background, mean, na.rm=TRUE)
ProfReadingL2_SD <-aggregate(L2read~AgeGroup, data=Background, sd, na.rm=TRUE)

#get means for use
LangUseChild_M <-aggregate(UseChild~AgeGroup, data=Background, mean, na.rm=TRUE)
LangUseChild_SD <-aggregate(UseChild~AgeGroup, data=Background, sd, na.rm=TRUE)
LangUseAdult_M <-aggregate(UseAdult~AgeGroup, data=Background, mean, na.rm=TRUE)
LangUseAdult_SD <-aggregate(UseAdult~AgeGroup, data=Background, sd, na.rm=TRUE)

#get means for daily switching
DailySwitch_M <-aggregate(DailySwitch~AgeGroup, data=Background, mean, na.rm=TRUE)
DailySwitch_SD <-aggregate(DailySwitch~AgeGroup, data=Background, sd, na.rm=TRUE)
ConvSwitch_M <-aggregate(ConvSwitch~AgeGroup, data=Background, mean, na.rm=TRUE)
ConvSwitch_SD <-aggregate(ConvSwitch~AgeGroup, data=Background, sd, na.rm=TRUE)
SentSwitch_M <-aggregate(SentSwitch~AgeGroup, data=Background, mean, na.rm=TRUE)
SentSwitch_SD <-aggregate(SentSwitch~AgeGroup, data=Background, sd, na.rm=TRUE)

#get t-tests for switching and use
LangUseChildTest <- t.test(UseChild ~ AgeGroup, data=Background)
LangUseAdultTest <- t.test(UseAdult ~ AgeGroup, data=Background)
DailySwitchTest <- t.test(DailySwitch ~ AgeGroup, data=Background)
ConvSwitchTest <- t.test(ConvSwitch ~ AgeGroup, data=Background)
SentSwitchTest <- t.test(SentSwitch ~ AgeGroup, data=Background)
#no age group diffs

#get anova for self-rated proficiency per type (listening, speaking, reading, writing)
Background_longSpeak <- Background %>%
  gather(key = "LanguageSpeak", value = "scoreSpeak", L1Speak,L2Speak) %>%
  convert_as_factor(Participant,LanguageSpeak)

Background_longUnderstand <- Background%>%
  gather(key = "LanguageUnderstand", value = "scoreUnderstand", L1understand,L2understand) %>%
  convert_as_factor(Participant,LanguageUnderstand)

Background_longWrite <- Background%>%
  gather(key = "LanguageWrite", value = "scoreWrite", L1write,L2write) %>%
  convert_as_factor(Participant,LanguageWrite)

Background_longread <- Background%>%
  gather(key = "LanguageRead", value = "scoreRead", L1read,L2read) %>%
  convert_as_factor(Participant,LanguageRead)

SpeakAnova <- aov(scoreSpeak~ AgeGroup*LanguageSpeak + Error(Participant/LanguageSpeak), Background_longSpeak)
summary(SpeakAnova) #no significant effects, apart from lang diff
UnderstandAnova <- aov(scoreUnderstand~ AgeGroup*LanguageUnderstand + Error(Participant/LanguageUnderstand), Background_longUnderstand)
summary(UnderstandAnova) #no significant effects, apart from lang diff
WriteAnova <- aov(scoreWrite~ AgeGroup*LanguageWrite + Error(Participant/LanguageWrite), Background_longWrite)
summary(WriteAnova) #older adults rate L2 writing lower
ReadAnova <- aov(scoreRead~ AgeGroup*LanguageRead + Error(Participant/LanguageRead), Background_longread)
summary(ReadAnova) #no significant effects, apart from lang diff


MixingZ <- summary(lme_Bilingual_Exp2_mixing_zscore_1)
SwitchingZ <- summary(lme_Bilingual_Exp2_switching_1_zscore)

```


$^1$Department of Psychology, University of York, York, United Kingdom  
$^2$Hull York Medical School, University of York, York, United Kingdom



**Corresponding author:**  
Angela de Bruin  
Department of Psychology  
University of York  
York YO10 5DD  
United Kingdom  
angela.debruin@york.ac.uk




For the purpose of open access a Creative Commons Attribution (CC BY) licence is applied to any Author Accepted Manuscript version arising from this submission.

\newpage
# Abstract {.unnumbered}
Word retrieval during language production slows down with age. However, bilinguals also require language control to manage language competition, in particular when switching languages to cues. The current study examined how this bilingual language control differs between younger and older adults. It also compared bilingual control, and age-group differences, to control that might be applied when alternating between responses within one language. In Experiment 1, 40 younger and 40 older monolingual adults completed a task alternating between noun and verb responses to pictures. The task showed costs associated with language control but these did not differ between age groups. Experiment 2 was completed by 50 older and 50 younger bilingual adults. Older adults showed larger switching costs than younger adults when switching between and within languages, suggesting they experienced more difficulty with reactive control. However, while older adults showed larger mixing costs than younger adults when using two languages in the dual-language environment relative to the single-language environment, they surprisingly showed smaller mixing costs than younger adults in the noun-verb within-language naming task. These findings show that language control, and the way it differs between older and younger adults, is not the same across within- and bilingual-language competition. 

\newpage
# Introduction
With ageing, several cognitive functions change, including language. Older adults are less accurate in confrontational naming tasks (cf. [1]), experience more tip-of-the-tongue moments where they cannot retrieve a specific word (e.g., [2]), and are slower to name pictures (e.g., [3]). Various mechanisms have been proposed to explain these changes in word retrieval with age. To some extent, slower language production can be explained through general slower processing in older adults ([4], but see [3]). However, focusing on language specifically, the Transmission Deficit Hypothesis ([5]) argues that slower or poorer word retrieval is the consequence of weakened connections between different nodes in the language production system. In order to retrieve a word, lexical nodes for words related in meaning to relevant concepts become active. To produce those words, phonological nodes need to be activated too. With age, the transmission from lexical to phonological nodes in particular might weaken, leading to slower or insufficient activation for production. 

While the majority of research has focused on changes in the retrieval of words, retrieval of target words alone might not be enough to allow for successful language production. We also need to manage competition from other, related words (e.g., “dog” when wanting to say “cat”). Older adults have greater difficulty suppressing irrelevant information while focusing on their goal [6]. This affects language too. For example, older adults are less coherent in story telling than younger adults, and this is modulated by their ability to suppress distracting relationships between words (e.g., [7]).

This language control might be particularly important when people speak more than one language, as these bilinguals need to manage competition between their languages (e.g., [8]). This control might be especially necessary when switching languages in response to different speakers, when bilinguals do not just need to select which words and language they want to use, but might also use inhibition to avoid interference from the previously used language [9]. 

The current study examines how age influences the way people use language control during language production. Furthermore, it compares whether similar control mechanisms might be used when switching between words within a language versus when switching between languages. Experiment 1 firstly examined within-language switching in a noun-verb switching task in younger and older adults. In Experiment 2, we compared this within-language switching to between-language switching in bilinguals, to examine the involvement of language control processes in both, as well as potential age-related effects.


## Bilingual language control
Bilingual language control has frequently been studied through cued language-switching paradigms, in which participants name digits or simple pictures. A cue, such as a country flag, indicates which language has to be used for a given picture. These studies typically find that bilinguals are slower to name a picture when they have to switch languages than on non-switch trials when they can use the same language as on the previous trial (switching cost; e.g., [10];[11]). These cued switching costs reflect reactive control processes that bilinguals apply in order to respond to the language cue, activate the new target language, and avoid interference from the language used on the previous trial (cf. [12] for a review). 

In addition, these tasks can compare non-switch trials from dual-language contexts to single-language contexts in which bilinguals know they should just use one specific language. Typically, cued tasks show a mixing cost, with bilinguals needing more time in dual- than single-language contexts. This can reflect various mechanisms related to more proactive and attentional control (cf. [13] for a review). A dual-language context requires closer cue monitoring to know which language to use. It also requires a bilingual to keep the language goal in mind and select the language accordingly. Finally, bilinguals might proactively balance the activation and/or inhibition of their languages to be able to flexibly use the two in dual-language contexts. 

Prominent models of language control (e.g., [9]) focus on language control in the form of inhibition, with bilinguals inhibiting the non-target language. How much inhibition is applied might depend on the language they are using. A more proficient language can create more interference and bilinguals are therefore argued to apply more control over the more proficient language (L1) than over less-proficient languages (L2; [9]). Although not always observed, unbalanced bilinguals who are more proficient in their L1 than L2 have been found to show an asymmetry in switching costs (e.g., [10]), with larger costs when switching to the L1 than L2. The inhibitory control hypothesis [9] explains this in terms of time needed to overcome previously applied inhibition. When using the L2, unbalanced bilinguals might strongly suppress the L1. When returning to the L1 on the next trial, time is needed to overcome the previously applied inhibition, leading to larger switching costs. Similar asymmetries have also been observed in terms of mixing costs (e.g., [14]; [15]), with bilinguals responding faster in their L1 than L2 in single-language blocks but not in dual-language blocks. This shows language proficiency can also influence more proactive control, potentially with bilinguals over-inhibiting their L1 in dual-language contexts to allow for easier use of the L2 in the same context. In some cases, this can even lead to reversed dominance effects, with participants responding faster in their L2 than L1 in dual-language contexts (cf. [16]). However, these findings can also be explained without purely relying on inhibition. Instead (or in addition), bilinguals might over-activate their L2 to allow for easier use in a dual-language context [17]. Following these accounts, (relatively) faster L2 than L1 responses in a dual-language context might be the consequence of this L2 over-activation.

Studies assessing language changes with age in bilinguals have, similar to studies with monolinguals, shown slower or reduced lexical retrieval (e.g., [18];[19]). However, language control also appears to change with age. Several studies (e.g., [20];[21];[22]) have found both switching and mixing costs to be larger for older than younger adults, suggesting both reactive and proactive control are affected. However, Hernandez and Kohnert [23] only observed age-group differences in terms of mixing costs but not switching costs. In contrast, Weissberger and colleagues [21] suggested that the age-group differences might be strongest for switching. Finally, Calabria et al. [24] found no age-group differences on language switching beyond overall slower naming. Thus, based on the current literature, it remains unclear whether age affects both reactive and proactive language control. 


## Language control in between- versus within-language competition
Furthermore, an open question is whether this language control is specific to resolving competition between languages or is also applied when resolving competition between words within a language. In particular when weaker relationships or words have to be retrieved, for example the less dominant meaning of an ambiguous word like bank [7], top-down control might be applied. In bilingual language production models (e.g., [9]), language control involves both bottom-up processes (e.g., an external cue telling the bilingual which language to use) and top-down control processes (e.g., inhibition and/or activation of specific languages). However, in influential models of (monolingual) word production, competition between words is often resolved just through bottom-up processes rather than top-down processes, for example by words being selected when they exceed the activation level of other words (e.g., [25];[26]). Inhibition can be part of this (e.g., [27]), but typically in the form of lateral rather than top-down inhibition, so that word representations inhibit competitors directly.  Top-down control is often not incorporated in these models (see [28] for a discussion; and [29] for an example of how top-down mechanisms can be implemented). 

However, research has shown top-down control might be used when controlling responses in one language too. For instance, Piai and colleagues [30] compared picture naming while ignoring distractors (e.g., picture of a dog while ignoring “cat”), colour naming while ignoring distractors in a Stroop task; and a non-linguistic task requiring object discrimination while ignoring its spatial position (Simon task). Incongruent trials in all conditions showed increased activation in the anterior cingulate cortex (ACC), an area associated with domain-general attentional control.
Previous research has therefore also compared if markers associated with language control observed in bilingual language switching are also present in within-language switching. Markers such as mixing and switching costs and reversed dominance effects are difficult to explain without any form of top-down control (cf. [16];[31]). Ivanova and Hernandez [31] asked participants to name pictures using either basic-level responses (like “shoe”) or a subordinate name (like “sneaker”). Participants named pictures in blocks following the same rule or in blocks in which they had to alternate between the two rules. Switching costs, mixing costs, and asymmetries as well as reversed dominance effects were observed, leading the authors to conclude that, similar to bilingual language control, within-language competition might also trigger top-down control.

While within- and between-language control were not directly compared by Ivanova and Hernandez, Declerck and colleagues [32] compared the two by asking French-English participants to switch languages or to switch between using formal or informal words in French. Both tasks showed significant switching costs, which correlated with each other and were comparable in size. This suggests similar control mechanisms were involved in the two types of switching. However, when manipulating the interval between the cue and stimulus, only language-switching but not register-switching costs were affected. Given that the cue-stimulus interval can be interpreted as active preparation of control processes in response to the cue, this suggests a difference in control mechanisms between language- and register-switching. Cattaneo and colleagues [33] also observed some similarities and some differences when comparing between-language switching to a noun-verb within-language switching task. Switching costs did not correlate between the two tasks. In contrast, mixing costs did correlate between the tasks, although this appeared to be driven by the group of Parkinson's Disease patients rather than the control group of older adults.

Finally, some studies have assessed within- versus cross-language interference by examining language switching in a paradigm with congruent or incongruent Stroop trials. Stroop trials require participants to name the physical colour of a word, which is either the same as the word itself (e.g., “red” in red ink, congruent) or different (e.g., “green” in red ink, incongruent). Some studies have shown larger language-switching costs in incongruent Stroop contexts (e.g., [34];[35]), suggesting that managing Stroop interference and between-language interference might recruit the same cognitive resources. However, not all studies have replicated these findings (e.g., [36]).


# Experiment 1

## Introduction
Thus, although there are suggestions in the literature that within-language switching might use language control too, it remains unclear whether these control processes are specific to within- or between-language competition or whether they are more general and comparable across the two. In the first Experiment, we tested a within-language switching task, with the aim of comparing this task to between-language switching in Experiment 2. We chose a task (similar to [33]) asking participants to name pictures while either using a noun to describe the object or a verb describing the action associated with it (e.g., “book” or “read”). The advantage of using this paradigm is that previous research has shown nouns are processed faster than verbs (e.g., [33];[37];[38], cf. [39] for a review including lesion research), allowing us to identify a priori the easy-to-use rule (using nouns, similar to the L1 being the easier to retrieve language) and the more difficult rule (using verbs, similar to words in the L2 being more difficult to retrieve). 
	
We furthermore examined how different types of control, if used within one language, might change with age. Previous research on bilingual control (as also further assessed in Experiment 2) has suggested that age can influence both reactive and proactive control processes. However, research on non-linguistic control has suggested age might affect proactive control more than reactive control. Several meta-analyses (e.g., [40];[41];[42]) have shown age effects predominantly occurring on tasks requiring participants to mix or use multiple tasks. For instance, Wasylyshyn and colleagues [42] showed clear age-group differences on task-mixing costs, suggesting older adults have increased difficulty completing two tasks in parallel, potentially also in relation to changes in working memory coordinating and maintaining multiple task rules within one context. However, the same meta-analysis showed no age-group differences in terms of task-switching costs, suggesting that more reactive control mechanisms are influenced less by age.

This leaves open the possibility that age also influences proactive control more strongly in language contexts. However, language control and executive control used in non-linguistic tasks might only overlap partially (e.g., [43];[44]). Furthermore, two studies comparing age effects on bilingual switching and task switching showed different patterns depending on the task. Calabria et al. [24] only observed age-group differences on non-linguistic switching costs but not on linguistic switching costs. Weissberger et al [21] showed clear age-group differences in both tasks but while the language-switching task showed differences in terms of both switching and mixing costs, the non-linguistic switching task only showed age-group differences on the mixing cost errors (in line with e.g., [42]). 
 

### Current study
Experiment 1 thus had two aims. First, it examined if monolinguals show effects typically associated with language control while switching between different types of words within one language. Specifically, we asked participants to name pictures while either using the noun to describe the object (e.g., “bed”) or the verb to describe an action associated with the object (e.g., “sleep”). They completed this task in single-rule contexts (always using the noun or verb) and dual-rule contexts, where they had to alternate between nouns and verbs in response to a cue. We examined whether participants showed switching costs (often used as a reflection of reactive control) and mixing costs (often used as a reflection of proactive control and effort associated with coordinating and maintaining multiple rules in mind). Furthermore, we examined asymmetries in these costs (with easier to retrieve responses being affected more by mixing or switching), as these in particular are often interpreted in line with control and inhibition (e.g., [16]).

As a second aim, Experiment 1 was completed by younger and older adults. If older adults have more difficulty with proactive control, we expected larger mixing costs in that age group, while their switching costs should be larger if their reactive control is affected. Finally, to examine whether any age-related differences are specific to language control, we also compared older and younger adults on a non-linguistic switching task in which they had to sort digits according to size (smaller or larger than 5) or parity (odd/even). For the non-linguistic switching task, we expected (in line with meta-analyses such as [42]) proactive control (mixing costs) to differ between age group while reactive control (switching costs) might be not or less affected.


## Methods

### Participants
Experiment 1 was completed by forty older adults (*M*age = 68.65 years old, *SD* = 3.82, range = 65-77) and forty younger adults (*M*age = 22.28, *SD* = 3.49, range = 18-29). 	Participants provided informed consent at the start of the study. Ethics approval was given by the ethics committee in the Department of Psychology, University of York. The study was conducted in accordance with the Declaration of Helsinki, with the exception of the requirement for pre-registration. All participants reported that they were native speakers of English, monolingual, and had not been diagnosed with language or reading difficulties, a neurological disorder, or cognitive impairment. They also reported having normal or corrected-to-normal vision and hearing and were not taking medication that could influence their concentration. Given that the study was conducted online, we did not use an assessment of cognitive functioning (e.g., MMSE). However, we used Prolific’s screening criteria to only invite participants without a history of cognitive impairment or dementia, which participants also confirmed in the questionnaire. Sample size was determined based on effect sizes typically observed for switching and mixing effects in bilingual switching tasks, which can be observed with >95% power with this sample size.  Given that age-group differences have not been studied on noun-verb switching tasks, we could not run a power analysis for the interaction between age and language control. Therefore, we followed the recommendation [45] to use 40 participants and 40 trials per combination of conditions for sufficient power in mixed-effect analyses.

Within the group of younger adults, 15 identified as male and 25 as female. Within the group of older adults, 22 identified as male and 18 as female. In terms of highest level of education achieved, 16 younger adults and 23 older adults reported having completed a graduate degree. 
An additional 12 participants were tested but excluded because they showed low accuracy (below 70% on the noun-verb switching task; N= 6), reported being bilingual (N=5), or reported having a neurological disorder or cognitive impairment (N=1).


### Design
Participants completed two switching tasks. The linguistic noun-verb switching task asked participants to name pictures using nouns (e.g., “bed”) and verb (e.g., “sleep”) responses. The non-linguistic switching task asked participants to respond to digits based on either their size or parity. Both tasks included a single-rule block (only requiring participants to follow one rule, for example always using nouns) and a dual-rule block, in which participants alternated between rules. Within the dual-rule block, some trials were switches (different rule than on previous trial) while other trials were non-switches (same rule as on previous trial). 

Per task, we conducted one set of analyses focusing on mixing effects (difference between single-rule and non-switch dual-rule trials) and one focusing on switching effects (difference between switch and non-switch trials within the dual-rule block). Each analysis included trial type (switch/non-switch; or non-switch/single-rule), rule (noun/verb for the linguistic task and size/parity for the non-linguistic task), and age group as predictors, and accuracy and reaction times as the dependent variables. 


###	Materials
For the linguistic noun-verb switching task, we selected twenty pictures from the MultiPic database [46]. We selected pictures that showed high naming agreement for the nouns. Furthermore, we ensured each picture had a concrete action associated with it that could be used when responding to the “verb” rule. Feedback was gathered from three speakers to choose pictures that only had one likely action associated with it. For instance, the picture of a chair has the specific action “sit” closely linked to it. An overview of the stimuli is provided on the OSF page: https://osf.io/rdfcs/. Verb and noun picture names were matched in terms of frequency and number of phonemes (see OSF page). All verbs were one syllable long and participants were asked to just name the infinitive, without “to”. All nouns were one or two syllables long. In the non-linguistic switching task, participants saw a digit between 1 and 4 or between 6 and 9 on the screen and responded to its size or parity with a button press.

Within each task, we used two written cues per rule to avoid a confound between cue and rule switching [47]. This way, even when the rule stayed the same (e.g., two trials in a row requiring a noun response), the cue still changed. In the linguistic noun-verb task, the words “NOUN” or “OBJECT” and “VERB” or “ACTION” were used as cues. In the non-linguistic task, the words “MAGNITUDE” or “SIZE” and “PARITY” or “EVENNESS” were used. 


### Procedure
Participants were recruited through Prolific.co and completed the study on Gorilla.sc [48]. After reading the information sheet and providing consent, participants first completed a short questionnaire. This questionnaire asked them about their age, gender, and education. Additional questions were included to ensure participants met our eligibility requirements (see “Participants” section). Afterwards, participants completed the linguistic and non-linguistic switching tasks, with the order counterbalanced across participants.

The linguistic noun-verb task started with a microphone check, in which participants were asked to record their verbal response to one picture. They could play back their response and were asked to only continue if they could hear themselves clearly in the recording. Next, they saw the picture familiarisation phase, in which they saw each picture with the written noun and verb responses next to it. This was included so that participants knew which pictures to expect and did not have to think about what objects and actions they were seeing while naming them. 

The main task included two single-rule blocks (one for nouns and one for verbs, with the order counterbalanced across participants), the dual-rule block, and another two single-rule blocks. The first two single-rule blocks were preceded by two practice trials with pictures that were not part of the main experiment; the dual-rule block was preceded by four practice trials.  Each picture was repeated once within each single-rule block, leading to a total of 80 single-rule trials (40 per rule). The dual-rule part included 160 trials, which were evenly distributed across trial type (switch/non-switch) and rule. Each picture was presented eight times. Stimulus order was pseudo-randomised so that pictures did not appear twice in a row and there were no more of four trials of the same rule or trial type in a row. Each picture was preceded by a fixation cross for 500ms and stayed on the screen for 3500ms, regardless of when the response was given.

The non-linguistic task followed the same set-up. Rather than giving verbal responses, participants saw four buttons on the screen: “<5”, “>5”, “even”, “odd”. Participants were shown an example and asked to click on “<5” or “>5” when following the magnitude rule and on “even” or “odd” when following the parity rule. The next trial was started as soon as a participant gave a response or moved on after ten seconds if no response was given. Before the fixation cross was shown, participants were asked to click on a button in the middle of the screen to reset the mouse position before the start of each trial. 


###	Data analysis

The data and analysis code can be found here: https://github.com/AMTdeBruin/Bilingual-switching-ageing. They are also available at https://osf.io/rdfcs/.
Verbal responses in the linguistic noun-verb switching task were recorded and scored for accuracy and naming onset time. A response was scored as correct if it was the target word or a similar alternative (e.g., “gift” instead of “present”). Responses were scored as incorrect if there was no response, if a different word was used (e.g., “apple” instead of “strawberry”), or if a response was given in the wrong language or combining two languages. Reaction times (RTs) relative to onset of picture presentation were determined using CheckVocal ([49], using CheckFile). 

We analysed age-group differences for each task separately, with one analysis focusing on switching cost (switch and non-switch trials only) and one analysis on mixing costs (non-switch and single-rule trials). Accuracy was not at ceiling and analysed using generalized linear mixed-effects models. RTs were analysed through linear mixed-effects models, using package *lme4* (version `r packageVersion('lme4')`) and *lmerTEST* (version `r packageVersion('lmerTest')`) in R (version `r paste0(R.Version()$major,'.', R.Version()$minor)`).

All analyses included Rule (noun coded as -0.5; verb as 0.5; or size coded as -0.5 and parity as 0.5); Age group (younger adults coded as -0.5; older adults as 0.5); and trial type (switching: non-switch coded as -0.5 and switch trials as 0.5; mixing: single-rule coded as -0.5 and non-switch trials as 0.5). For the accuracy analysis, we excluded trials in the dual-rule condition preceded by a break as they did not have a trial type (switch or non-switch). For RT analyses, we excluded incorrect responses and trials preceded by a break, no response, or wrong-language response. Prior to the RT analyses, we also removed RT outliers that fell 2.5*SD* above or below the mean by participant and condition (1.6% of correct noun-verb task trials and 1.9% of non-linguistic task trials, [50]). Visual inspection of the RT data showed that they were not normally distributed and we therefore conducted the analysis with log-transformed RTs. Descriptive statistics provided in the text and tables or figures are based on untransformed data.

All analyses started with maximal models including by-participant and by-item intercepts and all within-participant/-item slopes. When models did not converge, we first removed correlations between slopes and intercepts, followed by removal of item slopes that explained the lowest amount of variance. Details about the random-effects structure of the converging models are provided per results table. 

In the non-linguistic switching task, three participants performed below 70% correct. We did not exclude these participants as they performed above the threshold for the main task of interest, the linguistic noun-verb switching task. However, we reran the non-linguistic analyses without these three participants too, which showed the same results as when the analyses included them.

Finally, in addition to these analyses, we also examined whether the mixing and switching costs were related across the linguistic and non-linguistic switching tasks. For each participant, we therefore computed their switching cost (RT difference between switch and non-switch trials) and mixing cost (RT difference between non-switch and single-rule trials) per task and conducted correlational analyses comparing the costs across tasks. 


## Results
### Linguistic noun-verb switching task
#### Switching cost
\hfill\break

***Accuracy*** 

Mean accuracy scores by age group, trial type, and rule type are presented in Supplementary Table \@ref(tab:TableS1). Overall, accuracy was high, with means over 90% in all conditions. When errors were made, they mostly concerned responses following the incorrect rule (e.g., noun rather than verb). The analysis (see Supplementary Table \@ref(tab:TableS2)) revealed a main effect of trial type, reflecting that participants made more errors on switch than non-switch trials (see Supplementary Table \@ref(tab:TableS1)). This error switching cost did not interact with age group or rule.

***Reaction times***

Participants’ mean RTs per condition can be found in Table \@ref(tab:Table1). Table \@ref(tab:Table2) shows the full results of the switching-effect analysis. Participants showed a significant switching cost, with slower responses on switch trials (*M* = `r round(switchcostRT[3,2])`, *SD* = `r round(switchcostSD[3,2])`) than on non-switch trials (*M* = `r round(switchcostRT[1,2])`, *SD* = `r round(switchcostSD[1,2])`). While older adults (*M* = `r round(ageRT[1,2])`, *SD* = `r round(ageSD[1,2])`) responded more slowly numerically than the younger adults (*M* = `r round(ageRT[2,2])`, *SD* = `r round(ageSD[2,2])`), this difference did not reach significance in the dual-rule condition only. Of main interest for the current study, the switching cost did not differ between younger and older adults (see Table \@ref(tab:Table1)). None of the other main effects or interactions were significant either.

``` {r Table1}

table1data <- data.frame(matrix(0,nrow=15,ncol=3))
colnames(table1data) <- c('','Younger adults', 'Older adults')
table1data[,1] <- c('Single-rule','Noun','Verb','Non-switch','Noun','Verb','Switch','Noun','Verb','Mixing cost','Noun','Verb','Switching cost','Noun','Verb')

table1data[2,2] <- paste0(round(table1means[8,4]),' (',round(table1sds[8,4]),')')
table1data[3,2] <- paste0(round(table1means[6,4]),' (',round(table1sds[6,4]),')')
table1data[5,2] <- paste0(round(table1means[4,4]),' (',round(table1sds[4,4]),')')
table1data[6,2] <- paste0(round(table1means[2,4]),' (',round(table1sds[2,4]),')')
table1data[8,2] <- paste0(round(table1means[12,4]),' (',round(table1sds[12,4]),')')
table1data[9,2] <- paste0(round(table1means[10,4]),' (',round(table1sds[10,4]),')')
table1data[11,2] <- paste0(round(t1outM[1]),' (',round(t1outSD[1]),')')
table1data[12,2] <- paste0(round(t1outM[2]),' (',round(t1outSD[2]),')')
table1data[14,2] <- paste0(round(t1outM[3]),' (',round(t1outSD[3]),')')
table1data[15,2] <- paste0(round(t1outM[4]),' (',round(t1outSD[4]),')')

table1data[2,3] <- paste0(round(table1means[7,4]),' (',round(table1sds[7,4]),')')
table1data[3,3] <- paste0(round(table1means[5,4]),' (',round(table1sds[5,4]),')')
table1data[5,3] <- paste0(round(table1means[3,4]),' (',round(table1sds[3,4]),')')
table1data[6,3] <- paste0(round(table1means[1,4]),' (',round(table1sds[1,4]),')')
table1data[8,3] <- paste0(round(table1means[11,4]),' (',round(table1sds[11,4]),')')
table1data[9,3] <- paste0(round(table1means[9,4]),' (',round(table1sds[9,4]),')')
table1data[11,3] <- paste0(round(t1outM[5]),' (',round(t1outSD[5]),')')
table1data[12,3] <- paste0(round(t1outM[6]),' (',round(t1outSD[6]),')')
table1data[14,3] <- paste0(round(t1outM[7]),' (',round(t1outSD[7]),')')
table1data[15,3] <- paste0(round(t1outM[8]),' (',round(t1outSD[8]),')')

table1data[c(1,4,7,10,13),2:3] <- ' '

knitr::kable(table1data, booktabs = T, caption='Mean RTs (and standard deviations) in the noun-verb switching task in Experiment 1.', align='lll') %>%
  row_spec(0,bold=T)%>%
  row_spec(1,bold=T)%>%
  row_spec(4,bold=T)%>%
  row_spec(7,bold=T)%>%
  row_spec(10,bold=T)%>%
  row_spec(13,bold=T)
```

``` {r Table2}

table2valuesS <- summary(lme_LS_Exp1_2)
table2valuesM <- summary(lme_LS_Exp1_mixing_1)

table2data <- data.frame(matrix(0,nrow=18,ncol=5))
colnames(table2data) <- c('Fixed effects','Estimate', 'Standard Error','t-value','p-value')
table2data[,1] <- c('Switching analysis','Intercept','Switching','Rule','Age group','Switching x Age group','Switching x Rule','Age group x Rule','Switching x Age group x Rule','Mixing analysis','Intercept','Mixing','Rule','Age group','Mixing x Age group','Mixing x Rule','Age group x Rule','Mixing x Age group x Rule')

table2data[2:9,2:5] <- table2valuesS$coefficients[c(1,2,4,3,5,6,7,8),c(1,2,4,5)]
table2data[11:18,2:5] <- table2valuesM$coefficients[c(1,2,4,3,5,6,7,8),c(1,2,4,5)]

table2data[,2:4] <- round(table2data[,2:4],digits=3)
table2data[,5] <- p_format(table2data[,5],digits=2,leading.zero=TRUE,accuracy=0.001)

table2data[1,2:5] <- ' '
table2data[10,2:5] <- ' '

knitr::kable(table2data, booktabs = T, caption='Outcome of the linear mixed effect models for the linguistic noun-verb switching task in Experiment 1. The final model for the switching analysis included by-subject and by-item random intercepts, as well as all by-subject random slopes and all by-item slopes apart from age x switching. The final mixing model included all intercepts and slopes, after removal of correlations.', align='lrrrr') %>%
  row_spec(c(0,1,10),bold=T) %>%
  row_spec(c(1,10),italic=T)
  
```

#### Mixing cost
\hfill\break
***Accuracy***

The full results of the mixing cost error analysis are provided in Supplementary Table \@ref(tab:TableS2). The error analysis revealed a mixing cost, with participants making fewer errors in the single-rule condition than in the dual-rule condition (see Supplementary Table \@ref(tab:TableS1)). No further effects of, or interactions with, age group or rule were found.

***Reaction times***

The full results of the mixing cost RT analysis can be found in Table \@ref(tab:Table2), with descriptives shown in Table \@ref(tab:Table1). Participants showed a significant mixing cost, with slower responses on non-switch trials (*M* = `r round(switchcostRT[1,2])`, *SD* = `r round(switchcostSD[1,2])`) than on single-rule trials (*M* = `r round(switchcostRT[2,2])`, *SD* = `r round(switchcostSD[2,2])`). Across the single-rule and non-switch trials, older adults (*M* = `r round(ageRTmix[1,2])`, *SD* = `r round(ageSDmix[1,2])`) also responded more slowly than younger adults (*M* = `r round(ageRTmix[2,2])`, *SD* = `r round(ageSDmix[2,2])`). Of main interest for the current study, the mixing cost did not differ significantly between age groups (see Table 1).

The rule (noun or verb responses) influenced the mixing cost, such that the mixing cost was larger for noun decisions (*M*mixing cost = `r round(mmix2)`, *SD* = `r round(sdmix2)`) than for verb decisions (*M*mixing cost = `r round(mmix1)`, *SD* = `r round(sdmix1)`). While noun responses were faster than verb responses in the single-rule condition, the opposite was observed in the dual-rule condition (see Table \@ref(tab:Table1)).

###	Non-linguistic task
#### Switching and mixing costs
\hfill\break
***Accuracy***

Supplementary Table \@ref(tab:TableS3) presents the accuracy by condition in the non-linguistic task, with Supplementary Table \@ref(tab:TableS4) providing the results from the analyses. The error analysis showed a significant switching effect, but this was in the opposite direction of what was expected: accuracy was higher on switch trials than on non-switch trials (see Supplementary Table \@ref(tab:TableS3)). This was especially the case for the size-rule trials. There was also a significant mixing cost, with better performance in the single-rule condition. This interacted with age, but contrary to the prediction, this mixing cost was larger for younger than older adults (see Supplementary Table \@ref(tab:TableS3)).

***Reaction times***

Supplementary Table \@ref(tab:TableS5) provides the full results from the switching- and mixing-effect analyses. Both analyses (see Table \@ref(tab:Table3)) showed that older adults responded more slowly (*M* across all trial types = `r round(NLSswitchM2[1,2])`, *SD* = `r round(NLSswitchSD2[1,2])`) than younger adults (*M* across all trial types = `r round(NLSswitchM2[2,2])`, *SD* = `r round(NLSswitchSD2[2,2])`). Surprisingly, no switching effect was found (see Table 3), reflecting that switch (*M* = `r round(NLSswitchM[3,2])`, *SD* = `r round(NLSswitchSD[3,2])`) and non-switch RTs (*M* = `r round(NLSswitchM[1,2])`, *SD* = `r round(NLSswitchSD[1,2])`) were not significantly different. If anything, people were responding more slowly to non-switch trials, contrary to the hypothesis. There was a mixing effect, reflecting that responses were fastest on single-rule trials (*M* = `r round(NLSswitchM[2,2])`, *SD* = `r round(NLSswitchSD[2,2])`).

The switching effect was not significantly different between age groups. The mixing cost did differ between younger and older adults. In terms of untransformed RTs, older adults showed slightly higher mixing costs (see Table 3). However, in terms of log RTs (as used in the analysis), older adults’ mixing cost was smaller (*M* cost = `r round(logRT[1],digits=2)`, *SD* = `r round(logSD[1],digits=2)`) than that of younger adults (*M* cost = `r round(logRT[2],digits=2)`, *SD* = `r round(logSD[2],digits=2)`). Given that the direction differed between log RTs and untransformed RTs, and considering the large difference in overall RTs between age groups, we conducted an additional analysis using z-scored RTs. The interaction between age and mixing costs was not significant in this analysis ($\beta$ = `r round (Zscore_NLS$coefficients[c(5),c(1)],digits=3)`, *SE* = `r round (Zscore_NLS$coefficients[c(5),c(2)],digits=3)`, *t* = `r round (Zscore_NLS$coefficients[c(5),c(4)],digits=3)`, *p* = `r p_format (Zscore_NLS$coefficients[c(5),c(5)],digits=3,leading.zero=TRUE,accuracy=0.001)`).

``` {r Table3}

table3data <- data.frame(matrix(0,nrow=15,ncol=3))
colnames(table3data) <- c('','Younger adults', 'Older adults')
table3data[,1] <- c('Single-rule','Size','Parity','Non-switch','Size','Parity','Switch','Size','Parity','Mixing cost','Size','Parity','Switching cost','Size','Parity')

table3data[2,2] <- paste0(round(table3means[1,1]),' (',round(table3SDs[1,1]),')')
table3data[3,2] <- paste0(round(table3means[2,1]),' (',round(table3SDs[2,1]),')')
table3data[5,2] <- paste0(round(table3means[3,1]),' (',round(table3SDs[3,1]),')')
table3data[6,2] <- paste0(round(table3means[4,1]),' (',round(table3SDs[4,1]),')')
table3data[8,2] <- paste0(round(table3means[5,1]),' (',round(table3SDs[5,1]),')')
table3data[9,2] <- paste0(round(table3means[6,1]),' (',round(table3SDs[6,1]),')')
table3data[11,2] <- paste0(round(table3means[7,1]),' (',round(table3SDs[7,1]),')')
table3data[12,2] <- paste0(round(table3means[8,1]),' (',round(table3SDs[8,1]),')')
table3data[14,2] <- paste0(round(table3means[9,1]),' (',round(table3SDs[9,1]),')')
table3data[15,2] <- paste0(round(table3means[10,1]),' (',round(table3SDs[10,1]),')')

table3data[2,3] <- paste0(round(table3means[1,2]),' (',round(table3SDs[1,2]),')')
table3data[3,3] <- paste0(round(table3means[2,2]),' (',round(table3SDs[2,2]),')')
table3data[5,3] <- paste0(round(table3means[3,2]),' (',round(table3SDs[3,2]),')')
table3data[6,3] <- paste0(round(table3means[4,2]),' (',round(table3SDs[4,2]),')')
table3data[8,3] <- paste0(round(table3means[5,2]),' (',round(table3SDs[5,2]),')')
table3data[9,3] <- paste0(round(table3means[6,2]),' (',round(table3SDs[6,2]),')')
table3data[11,3] <- paste0(round(table3means[7,2]),' (',round(table3SDs[7,2]),')')
table3data[12,3] <- paste0(round(table3means[8,2]),' (',round(table3SDs[8,2]),')')
table3data[14,3] <- paste0(round(table3means[9,2]),' (',round(table3SDs[9,2]),')')
table3data[15,3] <- paste0(round(table3means[10,2]),' (',round(table3SDs[10,2]),')')

table3data[c(1,4,7,10,13),2:3] <- ' '

knitr::kable(table3data, booktabs = T, caption='Mean RTs (and standard deviations) in the non-linguistic switching task in Experiment 1.', align='lll') %>%
  row_spec(0,bold=T)%>%
  row_spec(1,bold=T)%>%
  row_spec(4,bold=T)%>%
  row_spec(7,bold=T)%>%
  row_spec(10,bold=T)%>%
  row_spec(13,bold=T)
  
```


###	Correlations

Finally, we examined whether the linguistic and non-linguistic switching and mixing effects were correlated. Non-linguistic and linguistic noun-verb switching costs were not significantly related: *r*(`r cor1output$parameter`) = `r round(cor1output$estimate,digits=3)`, *p* = `r round(cor1output$p.value, digits=3)`. Mixing costs showed a small correlation across tasks, although this was not significant with the Bonferroni corrected *p* value of 0.025: *r*(`r cor2output$parameter`) = `r round(cor2output$estimate, digits=3)`, *p* = `r round(cor2output$p.value, digits=3)`.

## Discussion
Experiment 1 tested a noun-verb switching task to examine whether markers of language control (switching and mixing costs) frequently observed in bilinguals are observed when switching within a language too. It furthermore compared those effects between younger and older adults, and compared the costs to a non-linguistic switching task. The noun-verb switching task showed both switching and mixing costs, but no age-group differences. The non-linguistic switching task showed, surprisingly, only a mixing and no switching cost.

### Within-language noun-verb switching
The noun-verb switching task showed that participants needed more time when switching between rules (switching cost) as well as when using two rules in a dual-rule condition compared to a single-rule condition (mixing cost), in line with [33]. The presence of mixing costs suggests that participants recruited additional resources to monitor cues and to select responses according to the rules indicated by the cues. The presence of switching costs furthermore shows that participants experienced competition between the different responses. Interestingly, the noun-verb mixing cost also showed an asymmetry, with participants showing larger RT mixing costs for the easier rule (object/noun naming). Although this did not reach significance, a similar numerical pattern was present in the accuracy analysis too, showing that the RT asymmetry was not the consequence of a speed-accuracy trade-off for, for example, the noun responses.

This pattern is in the same direction as asymmetries often observed in the bilingual production literature, either regarding switching costs (e.g., [10]) or mixing costs (e.g., [15]). These asymmetries are often explained through a form of language control, with people potentially inhibiting the easier responses to allow for flexible use of responses that are more difficult to retrieve. The finding that this asymmetry concerned mixing costs suggests that participants might have proactively inhibited noun responses to more easily use verb responses too. Alternatively, or additionally, they might have proactively over-activated the verb responses (e.g., [17]). This suggests some form of control is involved even in noun-verb switching. If the costs observed were purely due to more difficult words requiring more time to reach their activation threshold, the verbs should have shown larger mixing or switching costs. Instead, monolingual production might use language control too, in particular when speakers are required to alternate between responses in high-competition situations such as our dual-rule task.

Interestingly, age did not influence the mixing nor switching costs. More generally, within the dual-rule context, no overall age-group difference in terms of overall naming RTs was observed either. This is surprising as overall slower naming in older adults would be expected to be present, or even most pronounced, in the most-difficult dual language context. By comparing this task with the bilingual switching task in Experiment 2, we aim to better understand whether these groups of older adults performed at a similar level as younger adults regardless of the task or whether an absence of age-group differences is specific to within-language switching. 


### Task switching
Experiment 1 also included a (non-linguistic) task switching paradigm. Surprisingly, this task did not show a switching cost in terms of RTs and showed a switching benefit in terms of accuracy, contrary to a vast literature observing costs when switching between a range of tasks [51]. A large mixing cost was observed, showing that using different rules was more difficult than being in a single-rule condition. It is possible that the dual-rule condition was very difficult overall, even when not having to switch between rules. Even on non-switch trials, participants had to choose between one of two possible responses corresponding to the rule (for example, smaller or larger than 5 within the size-rule task). Responses in a linguistic noun-verb naming task might be more automatic, as language production is natural and people are fast at retrieving a word like “horse” in response to a picture. In contrast, determining whether 7 is smaller or larger than 5 might be difficult even on non-switch trials and is not a task people frequently perform in daily life. Furthermore, this might have been even more difficult in the online set-up, where participants had to click on, and remember, buttons corresponding to these options. Indeed, both age groups responded relatively slowly while doing this task. Older adults were significantly slower than younger adults. However, this larger age-group difference in terms of overall RTs could be explained by the general difficulty of the task and the absence of a strict time-out.

The very large mixing cost further confirms that the dual-rule context was difficult for both age groups and that participants might have put in much additional effort to respond to both non-switch and switch trials. A small difference in mixing costs between age groups was observed in the analysis on log RTs, although the direction varied for untransformed and log-transformed RTs. While the untransformed RTs suggest older adults had a larger mixing cost, the analysis on log RTs showed a smaller mixing cost for older adults. It is likely that the untransformed RTs show a larger raw mixing cost for older adults as their overall RTs were much slower than that of younger adults. This large increase in overall response times in older adults was only observed in the non-linguistic task, potentially also because the time out was much longer in this task (ten seconds). We therefore also conducted an additional analysis with z-scored RTs to cancel out the overall age effect (and indeed, in this analysis there was no overall RT age-group difference). This analysis no longer showed a significant age-group difference in terms of mixing costs. In combination with the benefit older adults showed in terms of the accuracy mixing cost too, it appears that older adults’ responses were not affected more negatively by dual-rule compared to single-rule contexts than younger adults’ responses. Thus, overall, neither the linguistic nor the non-linguistic tasks showed disadvantages for older adults.


# Experiment 2
## Introduction
The noun-verb switching task showed switching and mixing costs, as well as asymmetries with larger mixing costs when using the dominant rule in a dual-rule condition. The presence of these effects is similar to effects previously observed in the bilingualism literature and could suggest some degree of top-down language control is applied when switching responses within one language too. Experiment 2 firstly aimed to compare these effects across within-language and between-language switching to examine whether language-control mechanisms are applied similarly when managing competition within one language versus between two languages. We hypothesised that if reactive control is used similarly, switching costs should be comparable across tasks. Furthermore, if proactive control is used similarly, mixing costs, and potentially the asymmetry with larger costs for the L1 or noun responses, should be comparable too across tasks. Finally, given that semantic control has been associated with language production [7], we also included a measure of semantic control. This examined whether control is comparable when applied when suppressing alternate responses within a language, between languages, or between semantic relationships.

As a second aim, we examined how age affects within- and between-language control. Experiment 1 showed no clear language control differences between age groups, but previous literature has shown substantial age effects on bilingual control in terms of both reactive and proactive control mechanisms. If older adults show greater difficulty with proactive control, we expected their mixing costs to be larger than for younger adults. If these age-related changes are comparable across within- and between-language control, we expected these effects to be observed in both tasks, and for the age-group differences to be comparable. Similarly, if older adults show greater difficulty with reactive control, we expected their switching costs to be larger than those of younger adults, again also examining if age-related patterns are comparable for the within- and between-language control tasks.


## Methods
While Experiment 1 was not pre-registered, the pre-registration for Experiment 2 can be found at https://osf.io/rdfcs/.

### Participants
Experiment 2 was completed by fifty older adults (*M*age = 67.20 years old, *SD* = 5.60, range = 60-82) and fifty younger adults (*M*age = 23.1, *SD* = 4.97, range = 18-35). Participants provided informed consent at the start of the study. Ethics approval was given by the ethics committee in the Department of Psychology, University of York. The study was conducted in accordance with the Declaration of Helsinki, including a pre-registration. Thirty-four of the older adults identified as female and 16 as male. Within the group of younger adults, 34 identified as female, 13 as male, and three chose one of the other options. Thirty-eight of the older adults and twenty-five of the younger adults reported having completed a graduate degree. An additional seven participants were tested but not included because their audio files were not uploaded or audible (N=5) or because they did not follow the task instructions (N=2). The sample size was determined based on power simulations. We first ran a simulation assessing power to detect the switching and mixing costs observed for the noun-verb task in Experiment 1. With 100 participants, power to detect these effects was over 95%. Given that Experiment 1 showed no age-group differences, we based the power in relation to age groups on the bilingual switching study with older and younger adults reported in [22]. Power to detect a mixing cost difference between age groups was over 80%. Power to detect a switching cost difference between age groups, based on effect sizes in [22], was slightly lower (>60%). However, based on practical considerations regarding recruitment feasibility, we decided to accept this power with 100 participants. 

All participants reported that they were native speakers of English and met the same inclusion criteria as reported in Experiment 1. We again used the same Prolific screening settings and eligibility criteria regarding no diagnosis of a neurodegenerative disease or cognitive impairment. We did not use a separate task of cognitive functioning due to the study being completed online. Participants were bilingual in Experiment 2 and spoke French (39 older adults; 34 younger adults) or German (11 older adults; 16 younger adults) as a second language. We recruited both French- and German-speakers to facilitate recruitment but did not aim to compare French and German speakers. Participants completed the LexTALE as a short measure of vocabulary in each language ([52],[53]). In this task, they saw letter strings and had to indicate whether they formed an existing word in the target language or not. Participants also completed a language background questionnaire, which included questions about age of acquisition, self-rated proficiency, language use, and language switching. Participants reported being unbalanced bilinguals, with significantly higher proficiency in and use of English than their L2 (see Supplementary Table 6). Most participants were living in an English-dominant country (typically the UK). Some participants also reported speaking more than two languages, but for the purpose of our study, we always counted French or German as the L2, depending on the language version of the task they completed. We initially pre-registered to exclude participants who scored below 50% correct on the LexTALE. However, given that we aimed for unbalanced bilinguals with a lower L2 proficiency, several participants scored below this threshold and we removed this exclusion criterion. 


### Design
Participants completed a noun-verb switching task and a bilingual switching task. The design of these tasks was the same as in Experiment 1. They also completed a measure of semantic control, which asked them to assess the relationship between words in terms of their size or colour in the presence or absence of distractors (within-subject variable: high or low control).

### Materials
Pictures for the two switching tasks were chosen in a similar way as in Experiment 1, with the list of stimuli available on the OSF page. We used the same pictures in the bilingual and in the noun-verb switching task to make them more comparable. Identical cognates between the languages were avoided, which also resulted in a different set of stimuli for the noun-verb task than in Experiment 1. For some pictures, multiple verbs were possible (e.g., “chew”, “brush”, or “bite”), which we all accepted. Words were matched in terms of number of phonemes between languages or nouns/verbs, but the verb and L2 frequency was significantly higher than the noun and L1 frequencies. Materials for the semantic control task were based on [7]. Again, two cues per switching task were used. The cues for the noun-verb switching task were the same as in Experiment 1. For the bilingual switching task, we could not create two written cues per language and we therefore worked with two visual cues in the form of two versions of the country flag associated with the language.


### Procedure
Participants were recruited through Prolific.co and through our existing database of older adult volunteers. They completed the study on Gorilla.sc. The procedure of the study was similar to Experiment 1, with the order of the noun-verb and bilingual switching tasks counterbalanced across participants. The tasks looked the same as in Experiment 1, with the change that each picture was presented for 3000ms. After the two switching tasks, participants completed a semantic control task based on [7]. In this task, participants saw a target word and two or four answer options. They had to choose the answer option that was similar in either size (e.g., donkey–bicycle) or colour (e.g., cloud-tooth). Other answer options were either neutral (congruent trials) or distractors (incongruent trials) that were related to the target in another way. For example, on the incongruent trial asking what is most similar to “gym” in size, participants had to choose “theatre” while ignoring the related word “basketball”. Half of the trials were incongruent while the other half were congruent. There was no time limit on this task. After completing these tasks, participants completed the LexTALE tasks as a measure of vocabulary and the language background questionnaire, as described in the Participants section.


### Data analysis
Data analyses were similar to Experiment 1. We first examined age effects for the within-language and between-language switching tasks separately. Age effects on the RTs from the semantic control task were also analysed, with the variables age group and control condition (congruent = -0.5; incongruent = 0.5). To examine how language-control measures relate to each other and to semantic control, we also conducted four correlational analyses on within-language switching costs versus between-language switching costs; within-language mixing costs versus between-language mixing costs; semantic cost (RTs on incongruent trials minus congruent trials) versus within-language switching costs; and semantic cost versus between-language switching costs. Finally, we conducted two analyses assessing age effects across tasks. The first examined the switching costs from the bilingual and noun-verb switching task and the semantic control cost. This included the variables age group, task, and control condition (switch trials and incongruent semantic trials grouped as high control). Task was helmert coded to compare the bilingual and noun-verb switching costs to each other and the switching costs to the semantic control cost. The final analysis compared the mixing costs from the bilingual and noun-verb tasks, including age group, task (noun-verb = -0.5; bilingual = 0.5), and trial type. 

## Results
### Bilingual switching task
#### Switching analysis
\hfill\break

***Accuracy*** 

Mean accuracy per condition and language group is provided in Supplementary Table \@ref(tab:TableS7). The full results from the analysis are shown in Supplementary Table \@ref(tab:TableS8). The bilingual switching task showed a significant switching cost in terms of accuracy, with participants making more mistakes on switch than on non-switch trials. They were also more accurate in their L1 than in their L2. Accuracy did not show any effects of, or interactions with, age group.

***Reaction times***

The full results of the switching-effect analysis can be found in Table \@ref(tab:Table4), with Table \@ref(tab:Table5) showing the means per condition. Participants showed a significant switching cost, with slower responses on switch trials (*M* = `r round(Bil_Trialtype_RT_M[3,2])`, *SD* = `r round(Bil_Trialtype_RT_SD[3,2])`) than on non-switch trials (*M* = `r round(Bil_Trialtype_RT_M[1,2])`, *SD* = `r round(Bil_Trialtype_RT_SD[1,2])`). Older adults (*M* = `r round(Bil_Age_RT_M[1,2])`, *SD* = `r round(Bil_Age_RT_SD[1,2])`) responded more slowly than the younger adults (*M* = `r round(Bil_Age_RT_M[2,2])`, *SD* = `r round(Bil_Age_RT_SD[2,2])`). Of main interest for the current study, older adults had a slightly higher switching cost than younger adults, but this did not reach significance (see Table \@ref(tab:Table4) and Figure 1). None of the other main effects or interactions were significant either.

```{r Table4}

table4valuesS <- summary(lme_Bilingual_Exp2_1)
table4valuesM <- summary(lme_Bilingual_Exp2_mixing_1)

table4data <- data.frame(matrix(0,nrow=18,ncol=5))
colnames(table4data) <- c('Fixed effects','Estimate', 'Standard Error','t-value','p-value')
table4data[,1] <- c('Switching analysis','Intercept','Switching','Language','Age group','Switching x Age group','Switching x Language','Age group x Language','Switching x Age group x Language','Mixing analysis','Intercept','Mixing','Language','Age group','Mixing x Age group','Mixing x Language','Age group x Language','Mixing x Age group x Language')

table4data[2:9,2:5] <- table4valuesS$coefficients[c(1,2,4,3,5,6,7,8),c(1,2,4,5)]
table4data[11:18,2:5] <- table4valuesM$coefficients[c(1,2,4,3,5,6,7,8),c(1,2,4,5)]

table4data[,2:4] <- round(table4data[,2:4],digits=3)
table4data[,5] <- p_format(table4data[,5],digits=1,leading.zero=TRUE,accuracy=0.001)

table4data[1,2:5] <- ' '
table4data[10,2:5] <- ' '

knitr::kable(table4data, booktabs = T, caption='Outcome of the linear mixed effect models for the bilingual switching task in Experiment 2. The final switching model included all by-subject and by-item random intercepts and slopes, after removal of correlations. The final mixing model included all by-subject and by-item random intercepts and slopes, after removal of correlations.', align='lrrrr') %>%
  row_spec(c(0,1,10),bold=T) %>%
  row_spec(c(1,10),italic=T)
```


```{r Table5}
table5data <- data.frame(matrix(0,nrow=15,ncol=3))
colnames(table5data) <- c('','Younger adults', 'Older adults')
table5data[,1] <- c('Single-rule','L1','L2','Non-switch','L1','L2','Switch','L1','L2','Mixing cost','L1','L2','Switching cost','L1','L2')

table5data[2,2] <- paste0(round(table5means[1,1]),' (',round(table5SDs[1,1]),')')
table5data[3,2] <- paste0(round(table5means[2,1]),' (',round(table5SDs[2,1]),')')
table5data[5,2] <- paste0(round(table5means[3,1]),' (',round(table5SDs[3,1]),')')
table5data[6,2] <- paste0(round(table5means[4,1]),' (',round(table5SDs[4,1]),')')
table5data[8,2] <- paste0(round(table5means[5,1]),' (',round(table5SDs[5,1]),')')
table5data[9,2] <- paste0(round(table5means[6,1]),' (',round(table5SDs[6,1]),')')
table5data[11,2] <- paste0(round(table5means[7,1]),' (',round(table5SDs[7,1]),')')
table5data[12,2] <- paste0(round(table5means[8,1]),' (',round(table5SDs[8,1]),')')
table5data[14,2] <- paste0(round(table5means[9,1]),' (',round(table5SDs[9,1]),')')
table5data[15,2] <- paste0(round(table5means[10,1]),' (',round(table5SDs[10,1]),')')

table5data[2,3] <- paste0(round(table5means[1,2]),' (',round(table5SDs[1,2]),')')
table5data[3,3] <- paste0(round(table5means[2,2]),' (',round(table5SDs[2,2]),')')
table5data[5,3] <- paste0(round(table5means[3,2]),' (',round(table5SDs[3,2]),')')
table5data[6,3] <- paste0(round(table5means[4,2]),' (',round(table5SDs[4,2]),')')
table5data[8,3] <- paste0(round(table5means[5,2]),' (',round(table5SDs[5,2]),')')
table5data[9,3] <- paste0(round(table5means[6,2]),' (',round(table5SDs[6,2]),')')
table5data[11,3] <- paste0(round(table5means[7,2]),' (',round(table5SDs[7,2]),')')
table5data[12,3] <- paste0(round(table5means[8,2]),' (',round(table5SDs[8,2]),')')
table5data[14,3] <- paste0(round(table5means[9,2]),' (',round(table5SDs[9,2]),')')
table5data[15,3] <- paste0(round(table5means[10,2]),' (',round(table5SDs[10,2]),')')

table5data[c(1,4,7,10,13),2:3] <- ' '

knitr::kable(table5data, booktabs = T, caption='Mean RTs (and standard deviations) in the bilingual switching task in Experiment 2.', align='lll') %>%
  row_spec(0,bold=T)%>%
  row_spec(1,bold=T)%>%
  row_spec(4,bold=T)%>%
  row_spec(7,bold=T)%>%
  row_spec(10,bold=T)%>%
  row_spec(13,bold=T)
```



```{r makefig1, echo=FALSE, include=FALSE}
#### Figures ####
#four separate plots combined into one figure (Figure 1)
#bilingual switching cost plot
means_BSwitch_Exp2 <- Bilingual_Exp2_acc_outliers_switching %>% 
  group_by(participant, Trialtype, Agegroup) %>% 
  summarise(meanRT = mean(rawrt))
head(means_BSwitch_Exp2)

#get switching costs
means_BSwitch_Exp2_pivot <- means_BSwitch_Exp2 %>% 
  pivot_wider(id_cols = participant, names_from = c(Trialtype, Agegroup), values_from = meanRT)
head(means_BSwitch_Exp2_pivot)

#switching cost per participant
means_BSwitch_Exp2_pivot <- means_BSwitch_Exp2_pivot %>% 
  mutate(Older = switch_Older - nonswitch_Older,
         Younger = switch_Younger - nonswitch_Younger)
means_BSwitch_Exp2_long <- means_BSwitch_Exp2_pivot %>%
  pivot_longer(c(Older,Younger), 
               names_to = "Agegroup", 
               values_to = "BilingualSwitching",
               values_drop_na = TRUE)
head(means_BSwitch_Exp2_long)

#create first plot
BilingualSwitch = ggplot(means_BSwitch_Exp2_long, aes(x = Agegroup, y = BilingualSwitching)) + geom_boxplot() +
  labs(title="A. Bilingual switching cost",x="Age group", y = "Switching cost (ms)")+
  theme(axis.text.x = element_text(color = "black", size = 12, face = "plain"),
        axis.text.y = element_text(color = "black", size = 12, face = "plain"),
        axis.title.x = element_text(color = "black", size = 14, face = "bold"),
        axis.title.y = element_text(color = "black", size = 14, face = "bold"),
        title = element_text(color = "black", size = 14, face = "bold.italic"), 
        strip.text.x = element_text(color = "black", size = 12, face = "plain"))+
  
  theme(plot.title = element_text(hjust = 0.5))

BilingualSwitch = BilingualSwitch + ylim(-300, 300)+ geom_jitter(shape=16)+scale_fill_grey(start=0.6, end = 0.8) + stat_summary(fun=mean, geom="point", shape = 17, size=5, color="black") 
BilingualSwitch

#second part of the plot is the noun-verb switching cost
#noun-verb switching cost plot
means_NVSwitch_Exp2 <- NounVerb_Exp2_acc_outliers_switching %>% 
  group_by(participant, TrialType, Agegroup) %>% 
  summarise(meanRT = mean(rawrt))
head(means_NVSwitch_Exp2)

#get switching costs
means_NVSwitch_Exp2_pivot <- means_NVSwitch_Exp2 %>% 
  pivot_wider(id_cols = participant, names_from = c(TrialType, Agegroup), values_from = meanRT)
head(means_NVSwitch_Exp2_pivot)

#switching cost per participant
means_NVSwitch_Exp2_pivot <- means_NVSwitch_Exp2_pivot %>% 
  mutate(Older = switch_Older - nonswitch_Older,
         Younger = switch_Younger - nonswitch_Younger)
means_NVSwitch_Exp2_long <- means_NVSwitch_Exp2_pivot %>%
  pivot_longer(c(Older,Younger), 
               names_to = "Agegroup", 
               values_to = "NounVerbSwitching",
               values_drop_na = TRUE)
head(means_NVSwitch_Exp2_long)

#plot noun-verb switching
NVSwitch = ggplot(means_NVSwitch_Exp2_long, aes(x = Agegroup, y = NounVerbSwitching)) + geom_boxplot() +
  labs(title="B. Noun-verb switching cost",x="Age group", y = "Switching cost (ms)")+
  theme(axis.text.x = element_text(color = "black", size = 12, face = "plain"),
        axis.text.y = element_text(color = "black", size = 12, face = "plain"),
        axis.title.x = element_text(color = "black", size = 14, face = "bold"),
        axis.title.y = element_text(color = "black", size = 14, face = "bold"),
        title = element_text(color = "black", size = 14, face = "bold.italic"), 
        strip.text.x = element_text(color = "black", size = 12, face = "plain"))+
  
  theme(plot.title = element_text(hjust = 0.5))

NVSwitch = NVSwitch + ylim(-300, 300)+ geom_jitter(shape=16)+scale_fill_grey(start=0.6, end = 0.8) + stat_summary(fun=mean, geom="point", shape = 17, size=5, color="black") 
NVSwitch

#bilingual mixing cost plot
means_BMix_Exp2 <- Bilingual_Exp2_acc_outliers_mixing %>% 
  group_by(participant, Trialtype, Agegroup) %>% 
  summarise(meanRT = mean(rawrt))
head(means_BMix_Exp2)

#get mixing costs
means_BMix_Exp2_pivot <- means_BMix_Exp2 %>% 
  pivot_wider(id_cols = participant, names_from = c(Trialtype, Agegroup), values_from = meanRT)
head(means_BMix_Exp2_pivot)

#mixing cost per participant
means_BMix_Exp2_pivot <- means_BMix_Exp2_pivot %>% 
  mutate(Older = nonswitch_Older - SingleNaming_Older,
         Younger = nonswitch_Younger - SingleNaming_Younger)
means_BMix_Exp2_long <- means_BMix_Exp2_pivot %>%
  pivot_longer(c(Older,Younger), 
               names_to = "Agegroup", 
               values_to = "BilingualMixing",
               values_drop_na = TRUE)
head(means_BMix_Exp2_long)

#create bilingual mixing plot
BMix = ggplot(means_BMix_Exp2_long, aes(x = Agegroup, y = BilingualMixing)) + geom_boxplot() +
  labs(title="C. Bilingual mixing cost",x="Age group", y = "mixing cost (ms)")+
  theme(axis.text.x = element_text(color = "black", size = 12, face = "plain"),
        axis.text.y = element_text(color = "black", size = 12, face = "plain"),
        axis.title.x = element_text(color = "black", size = 14, face = "bold"),
        axis.title.y = element_text(color = "black", size = 14, face = "bold"),
        title = element_text(color = "black", size = 14, face = "bold.italic"), 
        strip.text.x = element_text(color = "black", size = 12, face = "plain"))+
  
  theme(plot.title = element_text(hjust = 0.5))

BMix = BMix + ylim(-250, 700)+ geom_jitter(shape=16)+scale_fill_grey(start=0.6, end = 0.8) + stat_summary(fun=mean, geom="point", shape = 17, size=5, color="black") 
BMix


#noun-verb mixing cost plot
means_NVMix_Exp2 <- NounVerb_Exp2_acc_outliers_mixing %>% 
  group_by(participant, TrialType, Agegroup) %>% 
  summarise(meanRT = mean(rawrt))
head(means_NVMix_Exp2)

#get mixing costs
means_NVMix_Exp2_pivot <- means_NVMix_Exp2 %>% 
  pivot_wider(id_cols = participant, names_from = c(TrialType, Agegroup), values_from = meanRT)
head(means_NVMix_Exp2_pivot)

#mixing cost per participant
means_NVMix_Exp2_pivot <- means_NVMix_Exp2_pivot %>% 
  mutate(Older = nonswitch_Older - SingleNaming_Older,
         Younger = nonswitch_Younger - SingleNaming_Younger)
means_NVMix_Exp2_long <- means_NVMix_Exp2_pivot %>%
  pivot_longer(c(Older,Younger), 
               names_to = "Agegroup", 
               values_to = "NounVerbMixing",
               values_drop_na = TRUE)
head(means_NVMix_Exp2_long)

#plot nounverb mixing cost
NVMix = ggplot(means_NVMix_Exp2_long, aes(x = Agegroup, y = NounVerbMixing)) + geom_boxplot() +
  labs(title="D. Noun-verb mixing cost",x="Age group", y = "mixing cost (ms)")+
  theme(axis.text.x = element_text(color = "black", size = 12, face = "plain"),
        axis.text.y = element_text(color = "black", size = 12, face = "plain"),
        axis.title.x = element_text(color = "black", size = 14, face = "bold"),
        axis.title.y = element_text(color = "black", size = 14, face = "bold"),
        title = element_text(color = "black", size = 14, face = "bold.italic"), 
        strip.text.x = element_text(color = "black", size = 12, face = "plain"))+
  
  theme(plot.title = element_text(hjust = 0.5))

NVMix = NVMix + ylim(-250, 700)+ geom_jitter(shape=16)+scale_fill_grey(start=0.6, end = 0.8) + stat_summary(fun=mean, geom="point", shape = 17, size=5, color="black") 
NVMix

pdf('Figure1.pdf',bg="transparent", height = 10, width = 10)

cowplot::plot_grid(BilingualSwitch, NVSwitch, BMix, NVMix) # put all four in one image

invisible(dev.off())

```

``` {r Figure1, fig.cap='Switching costs for the bilingual (A, top left) and noun-verb (B, top right) task per age group, as well as bilingual mixing (C, bottom left) and noun-verb mixing (D, bottom right) costs. The horizontal line in the box plot reflects the median while the centre of the triangle is the mean. Each dot reflects an individual participant (jittered).'}

knitr::include_graphics('Figure1.pdf')

```

#### Mixing analysis
\hfill\break

***Accuracy*** 

The full details are provided in Supplementary Tables \@ref(tab:TableS7) and \@ref(tab:TableS8). Participants showed a significant mixing cost, with higher accuracy on single-language trials than on dual-language trials. They were also more accurate in their L1 than L2. The mixing cost itself was also larger for the L1. The difference between languages (L1 naming advantage) was more pronounced on single-language than dual-language trials. Finally, this asymmetry in mixing cost interacted with age, as the difference between languages was largest for the younger adults.

***Reaction times***

Participants showed a significant RT mixing cost, with slower responses on non-switch trials (*M* = `r round(Bil_Trialtype_RT_M[1,2])`, *SD* = `r round(Bil_Trialtype_RT_SD[1,2])`) than on single-language trials (*M* = `r round(Bil_Trialtype_RT_M[2,2])`, *SD* = `r round(Bil_Trialtype_RT_SD[2,2])`). Across the single-language and non-switch trials, older adults (M = 1229, SD = 167) also responded more slowly than younger adults (M = 1136, SD = 145). Of main interest for the current study, mixing costs were larger in the older adults than in the younger adults (see Table 5 & Figure 1).

Participants furthermore responded faster in their L1 (*M* = `r round(Bil_LangMix_RT_M[1,2])`, *SD* = `r round(Bil_LangMix_RT_SD[1,2])`) than in their L2 (*M* = `r round(Bil_LangMix_RT_M[2,2])`, *SD* = `r round(Bil_LangMix_RT_SD[2,2])`). The mixing cost, however, interacted with language. The mixing cost was larger for the L1 (*M*mixing cost = `r round(Bil_L1Mix_RT_M)`, *SD* = `r round(Bil_L1Mix_RT_SD)`) than in the L2 (*M*mixing cost = `r round(Bil_L2Mix_RT_M)`, *SD* = `r round(Bil_L2Mix_RT_SD)`). As shown in Table \@ref(tab:Table5), participants were faster in their L1 than L2 in the single-language block, but not in the dual-language blocks. 

Given that older adults also responded significantly slower overall than younger adults, we z-scored the RTs to account for overall slowing. These analyses aimed to make sure that the larger mixing costs (and to some extent larger switching costs) for older adults were not the consequence of their overall slower naming. These analyses still showed a significant interaction between mixing costs and age ($\beta$ = `r round (MixingZ$coefficients[c(5),c(1)],digits=3)`, *SE* = `r round (MixingZ$coefficients[c(5),c(2)],digits=3)`, *t* = `r round (MixingZ$coefficients[c(5),c(4)],digits=3)`, *p* = `r p_format (MixingZ$coefficients[c(5),c(5)],digits=1,leading.zero=TRUE,accuracy=0.001)`), and the interaction between switching cost and age was now also significant ($\beta$ = `r round (SwitchingZ$coefficients[c(5),c(1)],digits=3)`, *SE* = `r round (SwitchingZ$coefficients[c(5),c(2)],digits=3)`, *t* = `r round (SwitchingZ$coefficients[c(5),c(4)],digits=3)`, *p* = `r p_format (SwitchingZ$coefficients[c(5),c(5)],digits=1,leading.zero=TRUE,accuracy=0.001)`).

### Noun-verb switching task
#### Switching analysis
\hfill\break

***Accuracy*** 

Mean accuracy by condition is shown in Supplementary Table \@ref(tab:tableS9), with full results from the analysis shown in Supplementary Table \@ref(tab:TableS10). There was a switch cost in terms of accuracy, with better performance on non-switch than switch trials. This interacted with rule, such that the switching cost was larger for the nouns. There were no effects of, or interactions with, age.

***Reaction times***

The full results of the switching-effect analysis can be found in Tables \@ref(tab:Table6) and \@ref(tab:Table7). Participants showed a significant switching cost, with slower responses on switch trials (*M* = `r round(NV_Trialtype_RT_M[3,2])`, *SD* = `r round(NV_Trialtype_RT_SD[3,2])`) than on non-switch trials (*M* = `r round(NV_Trialtype_RT_M[1,2])`, *SD* = `r round(NV_Trialtype_RT_SD[1,2])`). Overall RTs did not differ between age groups but the switching cost was larger for older than younger adults (see Table \@ref(tab:Table7) and Figure 1). None of the other main effects or interactions were significant.

```{r Table6}

table6valuesS <- summary(lme_NounVerb_Exp2_2)
table6valuesM <- summary(NounVerb_Exp2_mixing_2)

table6data <- data.frame(matrix(0,nrow=18,ncol=5))
colnames(table6data) <- c('Fixed effects','Estimate', 'Standard Error','t-value','p-value')
table6data[,1] <- c('Switching analysis','Intercept','Switching','Rule','Age group','Switching x Age group','Switching x Rule','Age group x Rule','Switching x Age group x Rule','Mixing analysis','Intercept','Mixing','Rule','Age group','Mixing x Age group','Mixing x Rule','Age group x Rule','Mixing x Age group x Rule')

table6data[2:9,2:5] <- table6valuesS$coefficients[c(1,2,4,3,5,6,7,8),c(1,2,4,5)]
table6data[11:18,2:5] <- table6valuesM$coefficients[c(1,2,4,3,5,6,7,8),c(1,2,4,5)]

table6data[,2:4] <- round(table6data[,2:4],digits=3)
table6data[,5] <- p_format(table6data[,5],digits=1,leading.zero=TRUE,accuracy=0.001)

table6data[1,2:5] <- ' '
table6data[10,2:5] <- ' '

knitr::kable(table6data, booktabs = T, caption='Outcome of the linear mixed effect models for the noun-verb switching task in Experiment 2. The final switching model included all by-subject and by-item random intercepts and slopes, apart from the item slope for switching x age x rule. The final mixing model included all intercepts and slopes after removal of correlations.', align='lrrrr') %>%
  row_spec(c(0,1,10),bold=T) %>%
  row_spec(c(1,10),italic=T)
```

```{r Table7}
table7data <- data.frame(matrix(0,nrow=15,ncol=3))
colnames(table7data) <- c('','Younger adults', 'Older adults')
table7data[,1] <- c('Single-rule','Noun','Verb','Non-switch','Noun','Verb','Switch','Noun','Verb','Mixing cost','Noun','Verb','Switching cost','Noun','Verb')

table7data[2,2] <- paste0(round(table7means[1,1]),' (',round(table7SDs[1,1]),')')
table7data[3,2] <- paste0(round(table7means[2,1]),' (',round(table7SDs[2,1]),')')
table7data[5,2] <- paste0(round(table7means[3,1]),' (',round(table7SDs[3,1]),')')
table7data[6,2] <- paste0(round(table7means[4,1]),' (',round(table7SDs[4,1]),')')
table7data[8,2] <- paste0(round(table7means[5,1]),' (',round(table7SDs[5,1]),')')
table7data[9,2] <- paste0(round(table7means[6,1]),' (',round(table7SDs[6,1]),')')
table7data[11,2] <- paste0(round(table7means[7,1]),' (',round(table7SDs[7,1]),')')
table7data[12,2] <- paste0(round(table7means[8,1]),' (',round(table7SDs[8,1]),')')
table7data[14,2] <- paste0(round(table7means[9,1]),' (',round(table7SDs[9,1]),')')
table7data[15,2] <- paste0(round(table7means[10,1]),' (',round(table7SDs[10,1]),')')

table7data[2,3] <- paste0(round(table7means[1,2]),' (',round(table7SDs[1,2]),')')
table7data[3,3] <- paste0(round(table7means[2,2]),' (',round(table7SDs[2,2]),')')
table7data[5,3] <- paste0(round(table7means[3,2]),' (',round(table7SDs[3,2]),')')
table7data[6,3] <- paste0(round(table7means[4,2]),' (',round(table7SDs[4,2]),')')
table7data[8,3] <- paste0(round(table7means[5,2]),' (',round(table7SDs[5,2]),')')
table7data[9,3] <- paste0(round(table7means[6,2]),' (',round(table7SDs[6,2]),')')
table7data[11,3] <- paste0(round(table7means[7,2]),' (',round(table7SDs[7,2]),')')
table7data[12,3] <- paste0(round(table7means[8,2]),' (',round(table7SDs[8,2]),')')
table7data[14,3] <- paste0(round(table7means[9,2]),' (',round(table7SDs[9,2]),')')
table7data[15,3] <- paste0(round(table7means[10,2]),' (',round(table7SDs[10,2]),')')

table7data[c(1,4,7,10,13),2:3] <- ' '

knitr::kable(table7data, booktabs = T, caption='Mean RTs (and standard deviations) in the noun-verb switching task in Experiment 2.', align='lll') %>%
  row_spec(0,bold=T)%>%
  row_spec(1,bold=T)%>%
  row_spec(4,bold=T)%>%
  row_spec(7,bold=T)%>%
  row_spec(10,bold=T)%>%
  row_spec(13,bold=T)

```


#### Mixing analysis
\hfill\break

***Accuracy*** 

Supplementary Tables \@ref(tab:tableS9) and \@ref(tab:TableS10) provide detail about the accuracy analysis. Accuracy was higher for single-rule than for non-switch trials. This mixing cost was furthermore larger for younger than older adults. Overall accuracy was higher for noun responses.

***Reaction times***

Participants showed a significant RT mixing cost, with slower responses on non-switch trials (*M* = `r round(NV_Trialtype_RT_M[1,2])`, *SD* = `r round(NV_Trialtype_RT_SD[1,2])`) than on single-rule trials (*M* = `r round(NV_Trialtype_RT_M[2,2])`, *SD* = `r round(NV_Trialtype_RT_SD[2,2])`). Of main interest for the current study, and contrary to the hypothesis, mixing costs were smaller in the older adults than in the younger adults (see Table \@ref(tab:Table7) and Figure 1).

Participants furthermore responded faster with nouns (*M* = `r round(NV_RuleMix_RT_M[2,2])`, *SD* = `r round(NV_RuleMix_RT_SD[2,2])`) than with verbs (*M* = `r round(NV_RuleMix_RT_M[1,2])`, *SD* = `r round(NV_RuleMix_RT_SD[1,2])`). The mixing cost, however, interacted with rule and was larger for nouns (*M*mixing cost = `r round(NV_MixingObject_RT_M)`, *SD* = `r round(NV_MixingObject_RT_SD)`) than verbs (*M*mixing cost = `r round(NV_MixingAction_RT_M)`, *SD* = `r round(NV_MixingAction_RT_SD)`). As shown in Table 7, the RT difference between nouns and verbs was reduced in the non-switch trials compared to the single-rule trials. 

### Comparisons across tasks

We also aimed to compare RTs across tasks, including the semantic control task. This task showed a main effect of age ($\beta$ = `r round (SemControl$coefficients[c(3),c(1)],digits=3)`, *SE* = `r round (SemControl$coefficients[c(3),c(2)],digits=3)`, *t* = `r round (SemControl$coefficients[c(3),c(4)],digits=3)`, *p* `r p_format (SemControl$coefficients[c(3),c(5)],digits=3,leading.zero=TRUE,accuracy=0.001)`), with older adults responding more slowly (*M* = `r round(Semantic_RTAge_M[1,2])`, *SD* = `r round(Semantic_RTAge_SD[1,2])`) than younger adults (*M* = `r round(Semantic_RTAge_M[2,2])`, *SD* = `r round(Semantic_RTAge_SD[2,2])`). There was also a main effect of control ($\beta$ = `r round (SemControl$coefficients[c(2),c(1)],digits=3)`, *SE* = `r round (SemControl$coefficients[c(2),c(2)],digits=3)`, *t* = `r round (SemControl$coefficients[c(2),c(4)],digits=3)`, *p* `r p_format (SemControl$coefficients[c(2),c(5)],digits=3,leading.zero=TRUE,accuracy=0.001)`), showing that people responded more slowly in the high-control condition (*M* = `r round(Semantic_RT_M[2,2])`, *SD* = `r round(Semantic_RT_SD[2,2])`) than in the low-control condition (*M* = `r round(Semantic_RT_M[1,2])`, *SD* = `r round(Semantic_RT_SD[1,2])`). The control cost was numerically higher for older (*M*cost = `r round(Semantic_CostOld_M)`, *SD* = `r round(Semantic_CostOld_SD)`) than younger adults (*M*cost = `r round(Semantic_CostYoung_M)`, *SD* = `r round(Semantic_CostYoung_SD)`), but this was not significant ($\beta$ = `r round (SemControl$coefficients[c(4),c(1)],digits=3)`, *SE* = `r round (SemControl$coefficients[c(4),c(2)],digits=3)`, *t* = `r round (SemControl$coefficients[c(4),c(4)],digits=3)`, *p* = `r p_format (SemControl$coefficients[c(4),c(5)],digits=3,leading.zero=TRUE,accuracy=0.001)`)

We then examined whether RT costs across the different tasks were significantly related to each other. None of them were (bilingual & noun-verb switching costs: *r*(`r corBNVswitchoutput$parameter`) = `r round(corBNVswitchoutput$estimate,digits=3)`, *p* = `r round(corBNVswitchoutput$p.value, digits=3)`; bilingual & noun-verb mixing costs: *r*(`r corBNVmixoutput$parameter`) = `r round(corBNVmixoutput$estimate,digits=3)`, *p* = `r round(corBNVmixoutput$p.value, digits=3)`; bilingual switching costs & semantic control cost: *r*(`r corSemanticBiloutput$parameter`) = `r round(corSemanticBiloutput$estimate,digits=3)`, *p* = `r round(corSemanticBiloutput$p.value, digits=3)`; noun-verb switching costs & semantic control cost: *r*(`r corSemanticNVoutput$parameter`) = `r round(corSemanticNVoutput$estimate,digits=3)`, *p* = `r round(corSemanticNVoutput$p.value, digits=3)`).

Next, the first analysis compared the switching costs and semantic control costs across tasks (see Supplementary Table \@ref(tab:TableS11) for the full results). There was a main effect of task, with responses being faster in the bilingual than in the noun-verb switching task (see Tables 5 and 7) and in the switching tasks than in the semantic task, with the latter not having a time limit per trial. Semantic control costs were larger than switching costs, with no significant difference between bilingual and noun-verb switching costs. Task also interacted with age group, reflecting that the overall RT difference between younger and older adults was larger on the bilingual task than on the noun-verb switching task, and also larger on the semantic task than on the switching tasks. Overall, in line with the individual task analyses, older adults showed larger switching/semantic costs than younger adults. Importantly, interactions between age group, task, and control costs were not significant, suggesting the age-group differences in terms of switching/control costs were not significantly more pronounced in one of the tasks than in the other.  

The second analysis aimed to examine whether age effects on mixing costs differed between the noun-verb and bilingual task. There was a significant mixing cost across tasks ($\beta$ = `r round (MixingTask$coefficients[c(2),c(1)],digits=3)`, *SE* = `r round (MixingTask$coefficients[c(2),c(2)],digits=3)`, *t* = `r round (MixingTask$coefficients[c(2),c(4)],digits=3)`, *p* `r p_format (MixingTask$coefficients[c(2),c(5)],digits=3,leading.zero=TRUE,accuracy=0.001)`), as also shown in the individual task analyses. There was also an effect of task ($\beta$ = `r round (MixingTask$coefficients[c(4),c(1)],digits=3)`, *SE* = `r round (MixingTask$coefficients[c(4),c(2)],digits=3)`, *t* = `r round (MixingTask$coefficients[c(4),c(4)],digits=3)`, *p* `r p_format (MixingTask$coefficients[c(4),c(5)],digits=3,leading.zero=TRUE,accuracy=0.001)`), with responses being slower in the noun-verb than in the bilingual task (see Tables 5 and 7). This interacted with age group ($\beta$ = `r round (MixingTask$coefficients[c(7),c(1)],digits=3)`, *SE* = `r round (MixingTask$coefficients[c(7),c(2)],digits=3)`, *t* = `r round (MixingTask$coefficients[c(7),c(4)],digits=3)`, *p* `r p_format (MixingTask$coefficients[c(7),c(5)],digits=3,leading.zero=TRUE,accuracy=0.001)`), confirming older adults were only slower than younger adults on the bilingual, but not on the noun-verb task. Finally, and of main interest, the three-way interaction between mixing, age, and task ($\beta$ = `r round (MixingTask$coefficients[c(8),c(1)],digits=3)`, *SE* = `r round (MixingTask$coefficients[c(8),c(2)],digits=3)`, *t* = `r round (MixingTask$coefficients[c(8),c(4)],digits=3)`, *p* `r p_format (MixingTask$coefficients[c(8),c(5)],digits=3,leading.zero=TRUE,accuracy=0.001)`) confirmed that the age effects differed between tasks, with older adults showing larger bilingual mixing costs but smaller noun-verb mixing costs (see Figure 1) than younger adults. None of the other main effects or interactions were significant (*p*s > 0.08).

## Discussion
Experiment 2 showed language-control costs in both the noun-verb and the bilingual task. In both tasks, we observed mixing costs, switching costs, and an asymmetry in mixing costs with larger RT costs for using the more proficient (L1) or dominant (noun) response. While the L1 was much faster than the L2 in the single-language condition, there was no difference between languages in the dual-language condition (and if anything, the L2 was actually slightly faster than the L1). This was driven by L1 performance slowing down more in the dual- than single-language condition than L2 RTs. Similarly, while noun responses were much faster in the single-rule condition, the difference with verb responses was smaller in the dual-rule condition. This suggests that in both types of tasks language control was applied more strongly over one of the languages or rules, in a proactive manner as indicated by this asymmetry occurring in terms of mixing but not switching costs. These asymmetries in mixing costs, sometimes leading to reversed language dominance effects in dual-language contexts, are frequently discussed in light of inhibition (e.g., [16]). Participants might have over-inhibited the L1 or noun responses in the dual-language/-rule condition to allow for easier use of the L2 or verb responses. Alternatively, or additionally, bilinguals might have activated the L2 or verbs more strongly in the dual-language/-rule condition to allow for easier use of both languages or rules, leading to smaller mixing costs for the L2/verbs.

We also showed age effects in both bilingual and in noun-verb switching tasks. In the noun-verb task, both mixing and switching costs were significantly affected but in different directions, with smaller mixing costs and larger switching costs for older adults. No overall age-group differences were observed in terms of general naming times across conditions. In the bilingual task, the age-group difference was as expected, with a larger mixing cost for older adults. Given that older adults were slower than younger adults overall, we also conducted analyses on z-scored RTs correcting for this overall slowing. These analyses too showed significantly larger mixing, as well as switching, costs for older adults. Older adults thus showed poorer reactive control on both tasks while only the bilingual (and not the within-language noun-verb) task showed poorer proactive control for older adults. These results will be discussed further in the General Discussion. 

# General Discussion
Across two Experiments, we examined age-group differences in tasks requiring participants to switch words between or within languages. Indications of language control (switching and mixing costs, as well as asymmetries with larger costs for the dominant rule) were observed in both tasks. However, these measures did not correlate between the within- and between-language tasks. Both tasks also showed age-group differences, but different patterns. For the noun-verb switching tasks, these age effects were only observed in Experiment 2 but concerned both mixing and switching, with the surprising finding that mixing costs were smaller for older adults in terms of accuracy as well as RTs. For the bilingual switching task, in contrast, larger RT mixing costs (and to some extent switching costs) were found for older adults. 

## Bilingual language switching and mixing
In line with previous literature assessing bilingual language switching in older adults (e.g., [20];[21];[22]), bilingual language control differed between age groups. This concerned the mixing costs in particular. This suggests older adults had greater difficulty monitoring cues and selecting languages accordingly in a dual-language environment. While overall mixing costs were larger for older adults, the asymmetry as such did not differ between age groups. This could suggest that older and younger adults proactively over-inhibited their L1 or over-activated their L2 in similar ways. Thus, overall control might diminish with age, but the way it is applied to each individual language might not change.

Switching costs appeared somewhat less affected by age, contrary to previous studies suggesting switching costs are most affected (e.g., [21] but cf. [42]). However, numerically switching costs were larger for older than younger adults too, and this reached significance in the z-scored RT analysis, suggesting that reactive control was affected in older adults too. Still, the age-group differences were most pronounced in terms of mixing costs. This is in line with task-switching literature (e.g., [42]) suggesting that older adults experience difficulties most strongly when it comes to keeping multiple rules and goals in mind in a dual-rule context.

Asymmetries in switching or mixing costs between the languages have specifically been linked to unbalanced bilinguals who are more proficient in one language than the other. Balanced bilinguals with more comparable proficiency and use of two languages would not be predicted to show an asymmetry (as similar levels of control would need to be applied over both languages) and indeed often have shown symmetrical switching costs (e.g., [22]). Thus, the asymmetries observed here are likely to be specific to unbalanced bilinguals. However, previous research with more balanced bilinguals ([22]) has also shown larger bilingual switching and mixing costs for older than younger adults. This suggests the observed age-group differences could apply to both balanced and unbalanced bilinguals, although future research is necessary to assess a potential relationship between a bilingual's daily-life language experiences and any age-group differences in terms of language control.

## Within-language switching and mixing
While Experiment 1 showed no age-group difference on mixing or switching costs in the within-language noun-verb switching task, Experiment 2 did. In line with the hypothesised direction, and in line with the bilingual task, switching costs were larger for older than younger adults. This suggests older adults experienced more difficulty with the reactive control needed to implement a response switch. In contrast, the mixing costs (surprisingly) were smaller for older adults, both for RTs and accuracy. In combination with the absence of age effects in Experiment 1, it is difficult to interpret why these mixing costs might be smaller. The smaller mixing costs seem a combination of older adults responding a bit slower than younger adults in the single-rule context but a bit faster in the dual-rule context. The combination of slower responses in the baseline and faster responses in the higher-control context leads to smaller mixing costs. It is possible, given the smaller cost in terms of RT and accuracy, that older adults applied more effort in the dual-rule context than younger adults, although this would raise the question why they only did this in the noun-verb but not in the bilingual switching task.

It is important to emphasise, however, that Experiment 1 did not show age effects. There are various differences between the Experiments that could perhaps explain differences in terms of results observed, although all are speculative. Although the task design was the same, we used slightly different stimuli that might have differed in difficulty level, with accuracy being slightly lower in Experiment 2. Furthermore, it is possible that monolinguals (Experiment 1) and bilinguals (Experiment 2) differ in how they use their language control or in their language processing or production more generally. Bilinguals are sometimes found to be slower in language production tasks than monolinguals (e.g., [54]), which is line with the slower naming observed in Experiment 2 compared to Experiment 1. Bilinguals in Experiment 2 also completed the noun-verb and bilingual switching tasks in the same session, using the same stimuli. However, in the absence of correlations between bilingual and noun-verb switching, the interpretation that the noun-verb pattern differences might be due to differences between bilinguals and monolinguals appears less likely. The surprising age-group differences observed for the noun-verb switching task, in combination with the expected patterns in the bilingual switching task, thus require future research to examine if – and potentially when – older adults experience less difficulty maintaining and using two within-language rules in mind than younger adults.

## Within- versus between-language switching
The within- and between-language switching tasks captured the same type of basic costs, including switching and mixing costs and an asymmetry in the mixing costs. Age effects were observed in both tasks and were comparable in terms of switching costs, which were larger for older than younger adults in both studies. Furthermore, the comparison between tasks showed that the age effect on switching cost did not differ across experiments. This suggests that older adults needed more time to implement reactive control both when switching within a language and when switching between languages. 

However, the switching costs did not correlate significantly across tasks, suggesting the underlying reactive control mechanisms might be different. Furthermore, while older adults showed larger bilingual mixing costs, they showed smaller mixing costs than younger adults in Experiment 2’s noun-verb task. Together, these patterns suggest that language control as applied within- versus between-language switching is different, at least in the type of task we assessed. This questions whether language control relies fully on domain-general mechanisms and instead suggests it might be applied in a task-specific manner. Furthermore, the type of control needed to manage competition between semantic relationships might also differ from the control used when switching between response types or languages. Although previous research [7] has shown relationships between semantic control and coherency in language production, our observed switching costs did not correlate with semantic control.

Nevertheless, future research is needed to examine different types of within-language competition. In the current study, we chose noun-verb switching to ensure we had one dominant rule (nouns), similar to the unbalanced bilinguals having one dominant language. However, in daily-life nouns and verbs are not necessarily in competition with each other. For instance, words like “climb” and “ladder” will often be used together within a sentence. Therefore, it is possible that the competition created within our task is not the type of within-language competition that speakers usually resolve in natural conversations. 

In conclusion, the way control changes with age depends on the way language users need to manage competition between words. Within bilingual environments requiring control over competition between two languages, older adults experience greater difficulty using two languages in response to cues. However, controlling competition between words within one language might not always be negatively affected by age.


\newpage
**Data availability**: 
A computationally reproducible version of this paper is available at: https://github.com/AMTdeBruin/Bilingual-switching-ageing.
Stimuli, data, and analysis scripts are available at the above link and, together with the pre-registration for Experiment 2, at DOI 10.17605/OSF.IO/RDFCS.

\newpage
# References {.unnumbered}
1.	Wen, H. & Dong, Y. The effect of ageing on confrontation naming in healthy older adults: a three-level meta-analysis. *J. Cogn. Psychol.* 1–29 (2023).
2.	Shafto, M. A., James, L. E., Abrams, L. & Tyler, L. K. Age-related increases in verbal knowledge are not associated with word finding problems in the Cam-CAN cohort: What you know won’t hurt you. *J. Gerontol. Ser. B* **72**, 100–106 (2017).
3.	Verhaegen, C. & Poncelet, M. Changes in naming and semantic abilities with aging from 50 to 90 years. *J. Int. Neuropsychol. Soc.* **19**, 119–126 (2013).
4.	Salthouse, T. A. Mediation of adult age differences in cognition by reductions in working memory and speed of processing. *Psychol. Sci.* **2**, 179–183 (1991).
5.	Burke, D. M., MacKay, D. G., Worthley, J. S. & Wade, E. On the tip of the tongue: What causes word finding failures in young and older adults? *J. Mem. Lang.* **30**, 542–579 (1991).
6.	Hasher, L. & Zacks, R. T. Working memory, comprehension, and aging: A review and a new view. *Psychol. Learn. Motiv.* **22**, 193–225 (1988).
7.	Hoffman, P., Loginova, E. & Russell, A. Poor coherence in older people’s speech is explained by impaired semantic and executive processes. *elife* **7**, e38907 (2018).
8.	Spivey, M. J. & Marian, V. Cross talk between native and second languages: Partial activation of an irrelevant lexicon. *Psychol. Sci.* **10**, 281–284 (1999).
9.	Green, D. W. Mental control of the bilingual lexico-semantic system. *Biling. Lang. Cogn.* **1**, 67–81 (1998).
10.	Meuter, R. F. & Allport, A. Bilingual language switching in naming: Asymmetrical costs of language selection. *J. Mem. Lang.* **40**, 25–40 (1999).
11.	Costa, A. & Santesteban, M. Lexical access in bilingual speech production: Evidence from language switching in highly proficient bilinguals and L2 learners. *J. Mem. Lang.* **50**, 491–511 (2004).
12.	Declerck, M. & Philipp, A. M. A review of control processes and their locus in language switching. *Psychon. Bull. Rev.* **22**, 1630–1645 (2015).
13.	Declerck, M. What about proactive language control? *Psychon. Bull. Rev.* **27**, 24–35 (2020).
14.	Christoffels, I. K., Firk, C. & Schiller, N. O. Bilingual language control: An event-related brain potential study. *Brain Res.* **1147**, 192–208 (2007).
15.	de Bruin, A., Roelofs, A., Dijkstra, T. & FitzPatrick, I. Domain-general inhibition areas of the brain are involved in language switching: FMRI evidence from trilingual speakers. *NeuroImage* **90**, 348–359 (2014).
16.	Goldrick, M. & Gollan, T. H. Inhibitory control of the dominant language: Reversed language dominance is the tip of the iceberg. *J. Mem. Lang.* **130**, 104410 (2023).
17. Philipp, A. M., Gade, M. & Koch, I. Inhibitory processes in language switching: Evidence from switching language-defined response sets. *Eur. J. Cogn. Psychol.* **19**, 395–416 (2007).
18.	Gollan, T. H., Montoya, R. I., Cera, C. & Sandoval, T. C. More use almost always means a smaller frequency effect: Aging, bilingualism, and the weaker links hypothesis. *J. Mem. Lang.* **58**, 787–814 (2008).
19.	Ivanova, I., Murillo, M., Montoya, R. I. & Gollan, T. H. Does bilingual language control decline in older age? *Linguist. Approaches Biling.* **6**, 86–118 (2016).
20.	Hernandez, A. E. & Kohnert, K. J. Aging and language switching in bilinguals. *Aging Neuropsychol. Cogn.* **6**, 69–83 (1999).
21.	Weissberger, G. H., Wierenga, C. E., Bondi, M. W. & Gollan, T. H. Partially overlapping mechanisms of language and task control in young and older bilinguals. *Psychol. Aging* **27**, 959 (2012).
22.	de Bruin, A., Samuel, A. G. & Duñabeitia, J. A. Examining bilingual language switching across the lifespan in cued and voluntary switching contexts. *J. Exp. Psychol. Hum. Percept. Perform.* **46**, 759 (2020).
23.	Hernandez, A. E. & Kohnert, K. J. Investigations into the locus of language-switching costs in older adult bilinguals. *Biling. Lang. Cogn.* **18**, 51–64 (2015).
24.	Calabria, M., Branzi, F. M., Marne, P., Hernández, M. & Costa, A. Age-related effects over bilingual language control and executive control. *Biling. Lang. Cogn.* **18**, 65–78 (2015).
25.	Levelt, W. J., Roelofs, A. & Meyer, A. S. A theory of lexical access in speech production. *Behav. Brain Sci.* **22**, 1–38 (1999).
26.	Roelofs, A. A spreading-activation theory of lemma retrieval in speaking. *Cognition* **42**, 107–142 (1992).
27.	Howard, D., Nickels, L., Coltheart, M. & Cole-Virtue, J. Cumulative semantic inhibition in picture naming: Experimental and computational studies. *Cognition* **100**, 464–482 (2006).
28.	Roelofs, A. How attention controls naming: Lessons from Wundt 2.0. *J. Exp. Psychol. Gen.* **150**, 1927 (2021).
29.	Roelofs, A. Goal-referenced selection of verbal action: modeling attentional control in the Stroop task. *Psychol. Rev.* **110**, 88 (2003).
30.	Piai, V., Roelofs, A., Acheson, D. J. & Takashima, A. Attention for speaking: domain-general control from the anterior cingulate cortex in spoken word production. *Front. Hum. Neurosci.* **7**, 832 (2013).
31.	Ivanova, I. & Hernandez, D. C. Within-language lexical interference can be resolved in a similar way to between-language interference. *Cognition* **214**, 104760 (2021).
32.	Declerck, M., Ivanova, I., Grainger, J. & Duñabeitia, J. A. Are similar control processes implemented during single and dual language production? Evidence from switching between speech registers and languages. *Biling. Lang. Cogn.* **23**, 694–701 (2020).
33. Cattaneo, G., Costa, A., Gironell, A., & Calabria, M. On the specificity of bilingual language control: A study with Parkinson's disease patients. *Biling. Lang. Cogn.* **23**, 570-578 (2020).
34.	Liu, C. et al. Symmetries of bilingual language switch costs in conflicting versus non-conflicting contexts. *Biling. Lang. Cogn.* **22**, 624–636 (2019).
35.	Yahya, M. & Özkan Ceylan, A. Interactions between language and inhibitory control: Evidence from a combined language switching and Stroop paradigm. *Int. J. Biling.* **26**, 675–694 (2022).
36.	Williams, G. P., Kirk, N. W., Sánchez, M., Afshar, Z. & Wen, Y. Shared or separate: Control processes of cross-and within-language interference. (2023). doi: 10.31234/osf.io/f82wk.
37. Szekely, A. et al. Timed action and object naming. *Cortex* **41**, 7-25 (2005).
38. Kauschke, C., & Stenneken, P. Differences in noun and verb processing in lexical decision cannot be attributed to word form and morphological complexity alone. *J. Psycholinguist. Res.* **37**, 443-452 (2008).
39. Mätzig, S., Druks, J., Masterson, J., & Vigliocco, G. Noun and verb differences in picture naming: Past studies and new evidence. *Cortex* **45**, 738-758 (2009).
40.	Verhaeghen, P., Steitz, D. W., Sliwinski, M. J. & Cerella, J. Aging and dual-task performance: a meta-analysis. *Psychol. Aging* **18**, 443 (2003).
41.	Verhaeghen, P. Aging and executive control: Reports of a demise greatly exaggerated. *Curr. Dir. Psychol. Sci.* **20**, 174–180 (2011).
42.	Wasylyshyn, C., Verhaeghen, P. & Sliwinski, M. J. Aging and task switching: a meta-analysis. *Psychol. Aging* **26**, 15 (2011).
43.	Calabria, M., Hernández, M., Branzi, F. M. & Costa, A. Qualitative differences between bilingual language control and executive control: Evidence from task-switching. *Front. Psychol.* **2**, 399 (2012).
44.	Declerck, M., Grainger, J., Koch, I. & Philipp, A. M. Is language control just a form of executive control? Evidence for overlapping processes in language switching and task switching. *J. Mem. Lang.* **95**, 138–145 (2017).
45.	Brysbaert, M. & Stevens, M. Power analysis and effect size in mixed effects models: A tutorial. *J. Cogn.* **1**, (2018).
46.	Duñabeitia, J. A. et al. MultiPic: A standardized set of 750 drawings with norms for six European languages. *Q. J. Exp. Psychol.* **71**, 808–816 (2018).
47.	Heikoop, K. W., Declerck, M., Los, S. A. & Koch, I. Dissociating language-switch costs from cue-switch costs in bilingual language switching. *Biling. Lang. Cogn.* **19**, 921–927 (2016).
48.	Anwyl-Irvine, A. L., Massonnié, J., Flitton, A., Kirkham, N. & Evershed, J. K. Gorilla in our midst: An online behavioral experiment builder. *Behav. Res. Methods* **52**, 388–407 (2020).
49.	Protopapas, A. Check Vocal: A program to facilitate checking the accuracy and response time of vocal responses from DMDX. *Behav. Res. Methods* **39**, 859–862 (2007).
50.	Grange, J.A.  trimr: An implementation of common response time trimming methods. R package version 1.0.1. (2015). https://cran.r-project.org/web/packages/trimr/index.html
51.	Kiesel, A. et al. Control and interference in task switching—A review. *Psychol. Bull.* **136**, 849 (2010).
52.	Lemhöfer, K. & Broersma, M. Introducing LexTALE: A quick and valid lexical test for advanced learners of English. *Behav. Res. Methods* **44**, 325–343 (2012).
53.	Brysbaert, M. Lextale_FR a fast, free, and efficient test to measure language proficiency in French. *Psychol. Belg.* **53**, 23–37 (2013).
54. Gollan, T. H., Montoya, R. I., Fennema-Notestine, C., & Morris, S. K. Bilingualism affects picture naming but not picture classification. *Mem. Cogn.* **33**, 1220-1234 (2005).

\newpage
**Acknowledgement**  
This work was supported by the INSPIRE grant generously awarded to Hull York Medical School by the Academy of Medical Sciences through the Wellcome Trust [Ref: IR5\1018]. We would like to thank Sheethal Pious Cyriac for her feedback on Experiment 2. We also would like to thank Daniel Baker for his help with the production of the reproducible version of this manuscript, which was supported by an Enhancing Research Culture award from Research England. 

**Author contributions**  
AdB designed and analysed both Experiments and wrote the main manuscript text. HK contributed to the design, data collection, and data processing of both Experiments. DH contributed to the design, data collection, and data processing of Experiment 1. All authors reviewed the manuscript. 

**Additional information**: 
The authors declare no competing interests.


\beginsupplement

\newpage
# Supplementary materials
**Manuscript title: A comparison of language control while switching within versus between languages in younger and older adults.**
**Authors: "Angela de Bruin, Heidi Kressel, & Daisy Hemmings**


**Experiment 1**
**Linguistic noun-verb switching task**


``` {r TableS1}

tableS1data <- data.frame(matrix(0,nrow=15,ncol=3))
colnames(tableS1data) <- c('','Younger adults', 'Older adults')
tableS1data[,1] <- c('Single-rule','Noun','Verb','Non-switch','Noun','Verb','Switch','Noun','Verb','Mixing cost','Noun','Verb','Switching cost','Noun','Verb')

tableS1data[2,2] <- paste0(round(100*tableS1means[8,4],digits=1),'% (',round(100*tableS1SDs[8,4],digits=1),')')
tableS1data[3,2] <- paste0(round(100*tableS1means[6,4],digits=1),'% (',round(100*tableS1SDs[6,4],digits=1),')')
tableS1data[5,2] <- paste0(round(100*tableS1means[4,4],digits=1),'% (',round(100*tableS1SDs[4,4],digits=1),')')
tableS1data[6,2] <- paste0(round(100*tableS1means[2,4],digits=1),'% (',round(100*tableS1SDs[2,4],digits=1),')')
tableS1data[8,2] <- paste0(round(100*tableS1means[12,4],digits=1),'% (',round(100*tableS1SDs[12,4],digits=1),')')
tableS1data[9,2] <- paste0(round(100*tableS1means[10,4],digits=1),'% (',round(100*tableS1SDs[10,4],digits=1),')')
tableS1data[11,2] <- paste0(round(tableS1mixswitch[1],digits=1),'% (',round(tableS1mixswitchSD[1],digits=1),')')
tableS1data[12,2] <- paste0(round(tableS1mixswitch[2],digits=1),'% (',round(tableS1mixswitchSD[2],digits=1),')')
tableS1data[14,2] <- paste0(round(tableS1mixswitch[3],digits=1),'% (',round(tableS1mixswitchSD[3],digits=1),')')
tableS1data[15,2] <- paste0(round(tableS1mixswitch[4],digits=1),'% (',round(tableS1mixswitchSD[4],digits=1),')')

tableS1data[2,3] <- paste0(round(100*tableS1means[7,4],digits=1),'% (',round(100*tableS1SDs[7,4],digits=1),')')
tableS1data[3,3] <- paste0(round(100*tableS1means[5,4],digits=1),'% (',round(100*tableS1SDs[5,4],digits=1),')')
tableS1data[5,3] <- paste0(round(100*tableS1means[3,4],digits=1),'% (',round(100*tableS1SDs[3,4],digits=1),')')
tableS1data[6,3] <- paste0(round(100*tableS1means[1,4],digits=1),'% (',round(100*tableS1SDs[1,4],digits=1),')')
tableS1data[8,3] <- paste0(round(100*tableS1means[11,4],digits=1),'% (',round(100*tableS1SDs[11,4],digits=1),')')
tableS1data[9,3] <- paste0(round(100*tableS1means[9,4],digits=1),'% (',round(100*tableS1SDs[9,4],digits=1),')')
tableS1data[11,3] <- paste0(round(tableS1mixswitch[5],digits=1),'% (',round(tableS1mixswitchSD[5],digits=1),')')
tableS1data[12,3] <- paste0(round(tableS1mixswitch[6],digits=1),'% (',round(tableS1mixswitchSD[6],digits=1),')')
tableS1data[14,3] <- paste0(round(tableS1mixswitch[7],digits=1),'% (',round(tableS1mixswitchSD[7],digits=1),')')
tableS1data[15,3] <- paste0(round(tableS1mixswitch[8],digits=1),'% (',round(tableS1mixswitchSD[8],digits=1),')')

tableS1data[c(1,4,7,10,13),2:3] <- ' '

knitr::kable(tableS1data, booktabs = T, caption='Mean accuracy (and standard deviations) in the noun-verb switching task in Experiment 1.', align='lll') %>%
  row_spec(0,bold=T)%>%
  row_spec(1,bold=T)%>%
  row_spec(4,bold=T)%>%
  row_spec(7,bold=T)%>%
  row_spec(10,bold=T)%>%
  row_spec(13,bold=T)%>%
  kable_styling(latex_options='HOLD_position')
  
```

\newpage

``` {r TableS2}

tableS2valuesS <- summary(glme_LS_accSwitching_Exp1_7)
tableS2valuesM <- summary(glme_LS_accMixing_Exp1_4)

tableS2data <- data.frame(matrix(0,nrow=18,ncol=5))
colnames(tableS2data) <- c('Fixed effects','Estimate', 'Standard Error','z-value','p-value')
tableS2data[,1] <- c('Switching cost analysis','Intercept','Switching','Rule','Age group','Switching x Age group','Switching x Rule','Age group x Rule','Switching x Age group x Rule','Mixing cost analysis','Intercept','Mixing','Rule','Age group','Mixing x Age group','Mixing x Rule','Age group x Rule','Mixing x Age group x Rule')

tableS2data[2:9,2:5] <- tableS2valuesS$coefficients[c(1,2,4,3,5,6,7,8),]
tableS2data[11:18,2:5] <- tableS2valuesM$coefficients[c(1,2,4,3,5,6,7,8),]

tableS2data[,2:4] <- round(tableS2data[,2:4],digits=3)
tableS2data[,5] <- p_format(tableS2data[,5],digits=1,leading.zero=TRUE,accuracy=0.001)

tableS2data[1,2:5] <- ' '
tableS2data[10,2:5] <- ' '

knitr::kable(tableS2data, booktabs = T, caption='Outcome of the generalised linear mixed effect models for the switching and mixing accuracy effect of the linguistic noun-verb switching task in Experiment 1. The final switching model included by-subject and by-item random intercepts, as well as by-subject slopes for switching and rule. The final mixing model included by-subject and by-item random intercepts, as well as all by-subject slopes and by-item slopes for age group, rule, mixing x rule, and age group x rule.', align='lrrrr') %>%
  row_spec(c(0,1,10),bold=T) %>%
  row_spec(c(1,10),italic=T)
  
```


\newpage

**Non-linguistic switching task**

``` {r TableS3}

tableS3data <- data.frame(matrix(0,nrow=15,ncol=3))
colnames(tableS3data) <- c('','Younger adults', 'Older adults')
tableS3data[,1] <- c('Single-rule','Size','Parity','Non-switch','Size','Parity','Switch','Size','Parity','Mixing cost','Size','Parity','Switching cost','Size','Parity')

tableS3data[2,2] <- paste0(round(100*tableS3means[8,4],digits=1),'% (',round(100*tableS3SDs[8,4],digits=1),')')
tableS3data[3,2] <- paste0(round(100*tableS3means[6,4],digits=1),'% (',round(100*tableS3SDs[6,4],digits=1),')')
tableS3data[5,2] <- paste0(round(100*tableS3means[4,4],digits=1),'% (',round(100*tableS3SDs[4,4],digits=1),')')
tableS3data[6,2] <- paste0(round(100*tableS3means[2,4],digits=1),'% (',round(100*tableS3SDs[2,4],digits=1),')')
tableS3data[8,2] <- paste0(round(100*tableS3means[12,4],digits=1),'% (',round(100*tableS3SDs[12,4],digits=1),')')
tableS3data[9,2] <- paste0(round(100*tableS3means[10,4],digits=1),'% (',round(100*tableS3SDs[10,4],digits=1),')')
tableS3data[11,2] <- paste0(round(tableS3mixswitch[1],digits=1),'% (',round(tableS3mixswitchSD[1],digits=1),')')
tableS3data[12,2] <- paste0(round(tableS3mixswitch[2],digits=1),'% (',round(tableS3mixswitchSD[2],digits=1),')')
tableS3data[14,2] <- paste0(round(tableS3mixswitch[3],digits=1),'% (',round(tableS3mixswitchSD[3],digits=1),')')
tableS3data[15,2] <- paste0(round(tableS3mixswitch[4],digits=1),'% (',round(tableS3mixswitchSD[4],digits=1),')')

tableS3data[2,3] <- paste0(round(100*tableS3means[7,4],digits=1),'% (',round(100*tableS3SDs[7,4],digits=1),')')
tableS3data[3,3] <- paste0(round(100*tableS3means[5,4],digits=1),'% (',round(100*tableS3SDs[5,4],digits=1),')')
tableS3data[5,3] <- paste0(round(100*tableS3means[3,4],digits=1),'% (',round(100*tableS3SDs[3,4],digits=1),')')
tableS3data[6,3] <- paste0(round(100*tableS3means[1,4],digits=1),'% (',round(100*tableS3SDs[1,4],digits=1),')')
tableS3data[8,3] <- paste0(round(100*tableS3means[11,4],digits=1),'% (',round(100*tableS3SDs[11,4],digits=1),')')
tableS3data[9,3] <- paste0(round(100*tableS3means[9,4],digits=1),'% (',round(100*tableS3SDs[9,4],digits=1),')')
tableS3data[11,3] <- paste0(round(tableS3mixswitch[5],digits=1),'% (',round(tableS3mixswitchSD[5],digits=1),')')
tableS3data[12,3] <- paste0(round(tableS3mixswitch[6],digits=1),'% (',round(tableS3mixswitchSD[6],digits=1),')')
tableS3data[14,3] <- paste0(round(tableS3mixswitch[7],digits=1),'% (',round(tableS3mixswitchSD[7],digits=1),')')
tableS3data[15,3] <- paste0(round(tableS3mixswitch[8],digits=1),'% (',round(tableS3mixswitchSD[8],digits=1),')')

tableS3data[c(1,4,7,10,13),2:3] <- ' '

knitr::kable(tableS3data, booktabs = T, caption='Mean accuracy (and standard deviations) in the non-linguistic switching task in Experiment 1.', align='lll') %>%
  row_spec(0,bold=T)%>%
  row_spec(1,bold=T)%>%
  row_spec(4,bold=T)%>%
  row_spec(7,bold=T)%>%
  row_spec(10,bold=T)%>%
  row_spec(13,bold=T)%>%
  kable_styling(latex_options='HOLD_position')
  
```


``` {r TableS4}

tableS4valuesS <- summary(glme_NLS_accSwitching_Exp1_10)
tableS4valuesM <- summary(glme_NLS_accMixing_Exp1_2)

tableS4data <- data.frame(matrix(0,nrow=18,ncol=5))
colnames(tableS4data) <- c('Fixed effects','Estimate', 'Standard Error','z-value','p-value')
tableS4data[,1] <- c('Switching cost analysis','Intercept','Switching','Rule','Age group','Switching x Age group','Switching x Rule','Age group x Rule','Switching x Age group x Rule','Mixing cost analysis','Intercept','Mixing','Rule','Age group','Mixing x Age group','Mixing x Rule','Age group x Rule','Mixing x Age group x Rule')

tableS4data[2:9,2:5] <- tableS4valuesS$coefficients[c(1,2,4,3,5,6,7,8),]
tableS4data[11:18,2:5] <- tableS4valuesM$coefficients[c(1,2,4,3,5,6,7,8),]

tableS4data[,2:4] <- round(tableS4data[,2:4],digits=3)
tableS4data[,5] <- p_format(tableS4data[,5],digits=1,leading.zero=TRUE,accuracy=0.001)

tableS4data[1,2:5] <- ' '
tableS4data[10,2:5] <- ' '

knitr::kable(tableS4data, booktabs = T, caption='Outcome of the generalised linear mixed effect models on accuracy switching and mixing costs in the non-linguistic switching task in Experiment 1. The final switching model included by-subject and by-item random intercepts plus the participant slope for rule. The final mixing model included by-subject and by-item random intercepts and all slopes apart from the by-item slope for mixing x age x rule.', align='lrrrr') %>%
  row_spec(c(0,1,10),bold=T) %>%
  row_spec(c(1,10),italic=T)%>%
  kable_styling(latex_options='HOLD_position')
  
```

\newpage

``` {r TableS5}

tableS5valuesS <- summary(lme_NLS_Exp1_2)
tableS5valuesM <- summary(lme_NLS_Exp1_mixing_2)

tableS5data <- data.frame(matrix(0,nrow=18,ncol=5))
colnames(tableS5data) <- c('Fixed effects','Estimate', 'Standard Error','t-value','p-value')
tableS5data[,1] <- c('Switching cost analysis','Intercept','Switching','Rule','Age group','Switching x Age group','Switching x Rule','Age group x Rule','Switching x Age group x Rule','Mixing cost analysis','Intercept','Mixing','Rule','Age group','Mixing x Age group','Mixing x Rule','Age group x Rule','Mixing x Age group x Rule')

tableS5data[2:9,2:5] <- tableS5valuesS$coefficients[c(1,2,4,3,5,6,7,8),c(1,2,4,5)]
tableS5data[11:18,2:5] <- tableS5valuesM$coefficients[c(1,2,4,3,5,6,7,8),c(1,2,4,5)]

tableS5data[,2:4] <- round(tableS5data[,2:4],digits=3)
tableS5data[,5] <- p_format(tableS5data[,5],digits=1,leading.zero=TRUE,accuracy=0.001)

tableS5data[1,2:5] <- ' '
tableS5data[10,2:5] <- ' '

knitr::kable(tableS5data, booktabs = T, caption='Outcome of the linear mixed effect models on RT switching and mixing costs for the non-linguistic switching task in Experiment 1. The final switching model included by-subject and by-item random intercepts and slopes, apart from the by-item slope for age x switching x rule. The final mixing model included by-subject and by-item intercepts and all slopes apart from the by-item slopes for rule x age and mixing x age.', align='lrrrr') %>%
  row_spec(c(0,1,10),bold=T) %>%
  row_spec(c(1,10),italic=T)%>%
  kable_styling(latex_options='HOLD_position')
  
```

\newpage

**Experiment 2**

```{r TableS6}

tableS6data <- data.frame(matrix(0,nrow=20,ncol=3))
colnames(tableS6data) <- c('','Younger adults', 'Older adults')
tableS6data[,1] <- c('L1: self-rated proficiency (1-10)','Speaking','Understanding','Writing','Reading','L2: self-rated proficiency (1-10)','Speaking','Understanding','Writing','Reading','Language use (1=all French/German, 5=all English)','Childhood','Adulthood','LexTale (0-100%)','English','French/German','Daily-life language switching (1=never, 7=very frequently)','Daily','Within a conversation','Within a sentence')

tableS6data[2,2] <- paste0(round(ProfSpeakingL1_M[2,2],digits=2),' (',round(ProfSpeakingL1_SD[2,2],digits=2),')')
tableS6data[3,2] <- paste0(round(ProfUnderstandingL1_M[2,2],digits=2),' (',round(ProfUnderstandingL1_SD[2,2],digits=2),')')
tableS6data[4,2] <- paste0(round(ProfWritingL1_M[2,2],digits=2),' (',round(ProfWritingL1_SD[2,2],digits=2),')')
tableS6data[5,2] <- paste0(round(ProfReadingL1_M[2,2],digits=2),' (',round(ProfReadingL1_SD[2,2],digits=2),')')
tableS6data[7,2] <- paste0(round(ProfSpeakingL2_M[2,2],digits=2),' (',round(ProfSpeakingL2_SD[2,2],digits=2),')')
tableS6data[8,2] <- paste0(round(ProfUnderstandingL2_M[2,2],digits=2),' (',round(ProfUnderstandingL2_SD[2,2],digits=2),')')
tableS6data[9,2] <- paste0(round(ProfWritingL2_M[2,2],digits=2),' (',round(ProfWritingL2_SD[2,2],digits=2),')')
tableS6data[10,2] <- paste0(round(ProfReadingL2_M[2,2],digits=2),' (',round(ProfReadingL2_SD[2,2],digits=2),')')

tableS6data[2,3] <- paste0(round(ProfSpeakingL1_M[1,2],digits=2),' (',round(ProfSpeakingL1_SD[1,2],digits=2),')')
tableS6data[3,3] <- paste0(round(ProfUnderstandingL1_M[1,2],digits=2),' (',round(ProfUnderstandingL1_SD[1,2],digits=2),')')
tableS6data[4,3] <- paste0(round(ProfWritingL1_M[1,2],digits=2),' (',round(ProfWritingL1_SD[1,2],digits=2),')')
tableS6data[5,3] <- paste0(round(ProfReadingL1_M[1,2],digits=2),' (',round(ProfReadingL1_SD[1,2],digits=2),')')
tableS6data[7,3] <- paste0(round(ProfSpeakingL2_M[1,2],digits=2),' (',round(ProfSpeakingL2_SD[1,2],digits=2),')')
tableS6data[8,3] <- paste0(round(ProfUnderstandingL2_M[1,2],digits=2),' (',round(ProfUnderstandingL2_SD[1,2],digits=2),')')
tableS6data[9,3] <- paste0(round(ProfWritingL2_M[1,2],digits=2),' (',round(ProfWritingL2_SD[1,2],digits=2),')')
tableS6data[10,3] <- paste0(round(ProfReadingL2_M[1,2],digits=2),' (',round(ProfReadingL2_SD[1,2],digits=2),')')

tableS6data[12,2] <- paste0(round(LangUseChild_M[2,2],digits=2),' (',round(LangUseChild_SD[2,2],digits=2),')')
tableS6data[13,2] <- paste0(round(LangUseAdult_M[2,2],digits=2),' (',round(LangUseAdult_SD[2,2],digits=2),')')
tableS6data[12,3] <- paste0(round(LangUseChild_M[1,2],digits=2),' (',round(LangUseChild_SD[1,2],digits=2),')')
tableS6data[13,3] <- paste0(round(LangUseAdult_M[1,2],digits=2),' (',round(LangUseAdult_SD[1,2],digits=2),')')

tableS6data[15,2] <- paste0(round(LexTaleL1_M[2,2],digits=2),' (',round(LexTaleL1_SD[2,2],digits=2),')')
tableS6data[15,3] <- paste0(round(LexTaleL1_M[1,2],digits=2),' (',round(LexTaleL1_SD[1,2],digits=2),')')
tableS6data[16,2] <- paste0(round(LexTaleL2_M[2,2],digits=2),' (',round(LexTaleL2_SD[2,2],digits=2),')')
tableS6data[16,3] <- paste0(round(LexTaleL2_M[1,2],digits=2),' (',round(LexTaleL2_SD[1,2],digits=2),')')

tableS6data[18,2] <- paste0(round(DailySwitch_M[2,2],digits=2),' (',round(DailySwitch_SD[2,2],digits=2),')')
tableS6data[18,3] <- paste0(round(DailySwitch_M[1,2],digits=2),' (',round(DailySwitch_SD[1,2],digits=2),')')
tableS6data[19,2] <- paste0(round(ConvSwitch_M[2,2],digits=2),' (',round(ConvSwitch_SD[2,2],digits=2),')')
tableS6data[19,3] <- paste0(round(ConvSwitch_M[1,2],digits=2),' (',round(ConvSwitch_SD[1,2],digits=2),')')
tableS6data[20,2] <- paste0(round(SentSwitch_M[2,2],digits=2),' (',round(SentSwitch_SD[2,2],digits=2),')')
tableS6data[20,3] <- paste0(round(SentSwitch_M[1,2],digits=2),' (',round(SentSwitch_SD[1,2],digits=2),')')


tableS6data[c(1,6,11,14,17),2:3] <- ' '

knitr::kable(tableS6data, booktabs = T, caption='Summary of the participants’ language proficiency in their L1 (English) and L2 (French or German). Means (and standard deviations) are provided for the LexTale measure of vocabulary, self-rated proficiency, language use during childhood (based on four questions on childhood and teenagers years at home and at school), language use during adulthood (based on 16 questions including different contexts, interlocutors, and activities), and daily-life switching in general, within a conversation, and within a sentence. Age groups did not differ significantly on any of the use or switching ratings. All proficiency measures showed significantly higher L1 than L2 proficiency. Older adults also performed better across both languages in the LexTale, but this did not interact with language. Self-rated speaking, understanding/listening, and reading did not differ between the age groups. Self-rated writing was lower for older adults, but given that our tasks did not use or assess writing, this was not problematic for the current study.', align='lll') %>%
  row_spec(0,bold=T)%>%
  row_spec(1,bold=T)%>%
  row_spec(6,bold=T)%>%
  row_spec(11,bold=T)%>%
  row_spec(14,bold=T)%>%
  row_spec(17,bold=T)%>%
  kable_styling(latex_options='HOLD_position')
```

\newpage
**Bilingual switching task**

```{r TableS7}

tableS7data <- data.frame(matrix(0,nrow=15,ncol=3))
colnames(tableS7data) <- c('','Younger adults', 'Older adults')
tableS7data[,1] <- c('Single-language','L1','L2','Non-switch','L1','L2','Switch','L1','L2','Mixing cost','L1','L2','Switching cost','L1','L2')

tableS7data[2,2] <- paste0(round(100*tableS7means[6,4],digits=1),'% (',round(100*tableS7SDs[6,4],digits=1),')')
tableS7data[3,2] <- paste0(round(100*tableS7means[8,4],digits=1),'% (',round(100*tableS7SDs[8,4],digits=1),')')
tableS7data[5,2] <- paste0(round(100*tableS7means[2,4],digits=1),'% (',round(100*tableS7SDs[2,4],digits=1),')')
tableS7data[6,2] <- paste0(round(100*tableS7means[4,4],digits=1),'% (',round(100*tableS7SDs[4,4],digits=1),')')
tableS7data[8,2] <- paste0(round(100*tableS7means[10,4],digits=1),'% (',round(100*tableS7SDs[10,4],digits=1),')')
tableS7data[9,2] <- paste0(round(100*tableS7means[12,4],digits=1),'% (',round(100*tableS7SDs[12,4],digits=1),')')
tableS7data[11,2] <- paste0(round(tableS7mixswitch[1],digits=1),'% (',round(tableS7mixswitchSD[1],digits=1),')')
tableS7data[12,2] <- paste0(round(tableS7mixswitch[2],digits=1),'% (',round(tableS7mixswitchSD[2],digits=1),')')
tableS7data[14,2] <- paste0(round(tableS7mixswitch[3],digits=1),'% (',round(tableS7mixswitchSD[3],digits=1),')')
tableS7data[15,2] <- paste0(round(tableS7mixswitch[4],digits=1),'% (',round(tableS7mixswitchSD[4],digits=1),')')

tableS7data[2,3] <- paste0(round(100*tableS7means[5,4],digits=1),'% (',round(100*tableS7SDs[5,4],digits=1),')')
tableS7data[3,3] <- paste0(round(100*tableS7means[7,4],digits=1),'% (',round(100*tableS7SDs[7,4],digits=1),')')
tableS7data[5,3] <- paste0(round(100*tableS7means[1,4],digits=1),'% (',round(100*tableS7SDs[1,4],digits=1),')')
tableS7data[6,3] <- paste0(round(100*tableS7means[3,4],digits=1),'% (',round(100*tableS7SDs[3,4],digits=1),')')
tableS7data[8,3] <- paste0(round(100*tableS7means[9,4],digits=1),'% (',round(100*tableS7SDs[9,4],digits=1),')')
tableS7data[9,3] <- paste0(round(100*tableS7means[11,4],digits=1),'% (',round(100*tableS7SDs[11,4],digits=1),')')
tableS7data[11,3] <- paste0(round(tableS7mixswitch[5],digits=1),'% (',round(tableS7mixswitchSD[5],digits=1),')')
tableS7data[12,3] <- paste0(round(tableS7mixswitch[6],digits=1),'% (',round(tableS7mixswitchSD[6],digits=1),')')
tableS7data[14,3] <- paste0(round(tableS7mixswitch[7],digits=1),'% (',round(tableS7mixswitchSD[7],digits=1),')')
tableS7data[15,3] <- paste0(round(tableS7mixswitch[8],digits=1),'% (',round(tableS7mixswitchSD[8],digits=1),')')

tableS7data[c(1,4,7,10,13),2:3] <- ' '

knitr::kable(tableS7data, booktabs = T, caption='Mean accuracy (and standard deviations) in the bilingual switching task in Experiment 2.', align='lll') %>%
  row_spec(0,bold=T)%>%
  row_spec(1,bold=T)%>%
  row_spec(4,bold=T)%>%
  row_spec(7,bold=T)%>%
  row_spec(10,bold=T)%>%
  row_spec(13,bold=T)%>%
  kable_styling(latex_options='HOLD_position')


```

\newpage

```{r TableS8}

tableS8valuesS <- summary(glme_Bilingual_accSwitching_Exp2_7)
tableS8valuesM <- summary(glme_Bilingual_accMixing_Exp2_3)

tableS8data <- data.frame(matrix(0,nrow=18,ncol=5))
colnames(tableS8data) <- c('Fixed effects','Estimate', 'Standard Error','z-value','p-value')
tableS8data[,1] <- c('Switching cost analysis','Intercept','Switching','Language','Age group','Switching x Age group','Switching x Language','Age group x Language','Switching x Age group x Language','Mixing cost analysis','Intercept','Mixing','Language','Age group','Mixing x Age group','Mixing x Language','Age group x Language','Mixing x Age group x Language')

tableS8data[2:9,2:5] <- tableS8valuesS$coefficients[c(1,2,4,3,5,6,7,8),]
tableS8data[11:18,2:5] <- tableS8valuesM$coefficients[c(1,2,4,3,5,6,7,8),]

tableS8data[,2:4] <- round(tableS8data[,2:4],digits=3)
tableS8data[,5] <- p_format(tableS8data[,5],digits=1,leading.zero=TRUE,accuracy=0.001)

tableS8data[1,2:5] <- ' '
tableS8data[10,2:5] <- ' '

knitr::kable(tableS8data, booktabs = T, caption='Outcome of the generalised linear mixed effect models for the switching and mixing accuracy effect of the bilingual switching task in Experiment 2. The final switching model included by-subject and by-item random intercepts, and the by-subject slope for language. The final mixing model included by-subject and by-item random intercepts, all by-subject slopes and by-item slopes for age, language, mixing x age, and age x language.', align='lrrrr') %>%
  row_spec(c(0,1,10),bold=T) %>%
  row_spec(c(1,10),italic=T)
```

\newpage
**Noun-verb switching task**

```{r tableS9}

tableS9data <- data.frame(matrix(0,nrow=15,ncol=3))
colnames(tableS9data) <- c('','Younger adults', 'Older adults')
tableS9data[,1] <- c('Single-rule','Noun','Verb','Non-switch','Noun','Verb','Switch','Noun','Verb','Mixing cost','Noun','Verb','Switching cost','Noun','Verb')

tableS9data[2,2] <- paste0(round(100*tableS9means[8,4],digits=1),'% (',round(100*tableS9SDs[8,4],digits=1),')')
tableS9data[3,2] <- paste0(round(100*tableS9means[6,4],digits=1),'% (',round(100*tableS9SDs[6,4],digits=1),')')
tableS9data[5,2] <- paste0(round(100*tableS9means[4,4],digits=1),'% (',round(100*tableS9SDs[4,4],digits=1),')')
tableS9data[6,2] <- paste0(round(100*tableS9means[2,4],digits=1),'% (',round(100*tableS9SDs[2,4],digits=1),')')
tableS9data[8,2] <- paste0(round(100*tableS9means[12,4],digits=1),'% (',round(100*tableS9SDs[12,4],digits=1),')')
tableS9data[9,2] <- paste0(round(100*tableS9means[10,4],digits=1),'% (',round(100*tableS9SDs[10,4],digits=1),')')
tableS9data[11,2] <- paste0(round(tableS9mixswitch[1],digits=1),'% (',round(tableS9mixswitchSD[1],digits=1),')')
tableS9data[12,2] <- paste0(round(tableS9mixswitch[2],digits=1),'% (',round(tableS9mixswitchSD[2],digits=1),')')
tableS9data[14,2] <- paste0(round(tableS9mixswitch[3],digits=1),'% (',round(tableS9mixswitchSD[3],digits=1),')')
tableS9data[15,2] <- paste0(round(tableS9mixswitch[4],digits=1),'% (',round(tableS9mixswitchSD[4],digits=1),')')

tableS9data[2,3] <- paste0(round(100*tableS9means[7,4],digits=1),'% (',round(100*tableS9SDs[7,4],digits=1),')')
tableS9data[3,3] <- paste0(round(100*tableS9means[5,4],digits=1),'% (',round(100*tableS9SDs[5,4],digits=1),')')
tableS9data[5,3] <- paste0(round(100*tableS9means[3,4],digits=1),'% (',round(100*tableS9SDs[3,4],digits=1),')')
tableS9data[6,3] <- paste0(round(100*tableS9means[1,4],digits=1),'% (',round(100*tableS9SDs[1,4],digits=1),')')
tableS9data[8,3] <- paste0(round(100*tableS9means[11,4],digits=1),'% (',round(100*tableS9SDs[11,4],digits=1),')')
tableS9data[9,3] <- paste0(round(100*tableS9means[9,4],digits=1),'% (',round(100*tableS9SDs[9,4],digits=1),')')
tableS9data[11,3] <- paste0(round(tableS9mixswitch[5],digits=1),'% (',round(tableS9mixswitchSD[5],digits=1),')')
tableS9data[12,3] <- paste0(round(tableS9mixswitch[6],digits=1),'% (',round(tableS9mixswitchSD[6],digits=1),')')
tableS9data[14,3] <- paste0(round(tableS9mixswitch[7],digits=1),'% (',round(tableS9mixswitchSD[7],digits=1),')')
tableS9data[15,3] <- paste0(round(tableS9mixswitch[8],digits=1),'% (',round(tableS9mixswitchSD[8],digits=1),')')

tableS9data[c(1,4,7,10,13),2:3] <- ' '

knitr::kable(tableS9data, booktabs = T, caption='Mean accuracy (and standard deviations) in the noun-verb switching task in Experiment 2.', align='lll') %>%
  row_spec(0,bold=T)%>%
  row_spec(1,bold=T)%>%
  row_spec(4,bold=T)%>%
  row_spec(7,bold=T)%>%
  row_spec(10,bold=T)%>%
  row_spec(13,bold=T)%>%
  kable_styling(latex_options='HOLD_position')


```

\newpage

```{r TableS10}

tableS10valuesS <- summary(glme_NounVerb_accuracySwitching_Exp2_3)
tableS10valuesM <- summary(glme_NounVerb_accuracyMixing_Exp2_2)

tableS10data <- data.frame(matrix(0,nrow=18,ncol=5))
colnames(tableS10data) <- c('Fixed effects','Estimate', 'Standard Error','z-value','p-value')
tableS10data[,1] <- c('Switching cost analysis','Intercept','Switching','Rule','Age group','Switching x Age group','Switching x Rule','Age group x Rule','Switching x Age group x Rule','Mixing cost analysis','Intercept','Mixing','Rule','Age group','Mixing x Age group','Mixing x Rule','Age group x Rule','Mixing x Age group x Rule')

tableS10data[2:9,2:5] <- tableS10valuesS$coefficients[c(1,2,4,3,5,6,7,8),]
tableS10data[11:18,2:5] <- tableS10valuesM$coefficients[c(1,2,4,3,5,6,7,8),]

tableS10data[,2:4] <- round(tableS10data[,2:4],digits=3)
tableS10data[,5] <- p_format(tableS10data[,5],digits=2,leading.zero=TRUE,accuracy=0.001)

tableS10data[1,2:5] <- ' '
tableS10data[10,2:5] <- ' '

knitr::kable(tableS10data, booktabs = T, caption='Outcome of the generalised linear mixed effect models for the switching and mixing accuracy effect of the linguistic noun-verb switching task in Experiment 2. The final switching model included by-subject and by-item random intercepts, all by-subject slopes, and by-item slopes for switching, rule, age group, and age group x rule. The final mixing model included by-subject and by-item intercepts, all by-subject slopes, and by-item slopes for mixing, age group, rule, and mixing x age group x rule.', align='lrrrr') %>%
  row_spec(c(0,1,10),bold=T) %>%
  row_spec(c(1,10),italic=T)

```

\newpage
**Semantic control task**

```{r TableS11}

tableS11values <- summary(lme_TaskComp_Exp2_control_3)

tableS11data <- data.frame(matrix(0,nrow=12,ncol=5))
colnames(tableS11data) <- c('Fixed effects','Estimate', 'Standard Error','t-value','p-value')
tableS11data[,1] <- c('Intercept','Control (high/low)','Task 1: Bilingual vs Noun-Verb','Task 2: Switching vs Semantic','Age group','Control x Age group','Control x Task 1','Control x Task 2','Age group x Task 1','Age group x Task 2','Control x Age group x Task 1','Control x Age group x Task 2')

tableS11data[1:12,2:5] <- tableS11values$coefficients[c(1,2,4,5,3,6,7,8,9,10,11,12),c(1,2,4,5)]

tableS11data[,2:4] <- round(tableS11data[,2:4],digits=3)
tableS11data[,5] <- p_format(tableS11data[,5],digits=2,leading.zero=TRUE,accuracy=0.001)



knitr::kable(tableS11data, booktabs = T, caption='Outcome of the linear mixed effect model comparing the switching costs and semantic control cost across the three tasks. The final switching model included by-subject and by-item random intercepts and by-subject slopes for difficulty and task. Task was helmert coded; task 1 refers to bilingual vs noun-verb switching while task 2 refers to the switching tasks vs the semantic control task.', align='lrrrr')%>%
  kable_styling(latex_options='HOLD_position')

```

